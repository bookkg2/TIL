## R

- 온라인 서적 : https://thebook.io/006723/ch01/

##### 

- ## 왜 R인가

  R[[1\]](https://thebook.io/006723/ch01/08/#ref1)은 데이터 분석을 위한 통계 및 그래픽스를 지원하는 자유 소프트웨어 환경이다. 

  R은 현재 데이터 분석을 위한 도구로 많은 인기를 누리고 있다. 한 가지 사례로 데이터 마이닝data mining이나 기계 학습machine learning에 대한 소식을 공유하는 사이트인 kdnugget에서 실시한 ‘지난 12개월간 실제로 사용한 분석, 데이터 마이닝, 빅데이터 소프트웨어’에 대한 설문 조사를 볼 수 있다. 그 내용에 따르면 래피드 마이너Rapid Miner, 웨카Weka, SAS, 매트랩MATLAB 등의 쟁쟁한 경쟁자와 비교했을 때 R은 2012년에 1위, 2013년에 2위를 차지해 그 인기가 높음을 알 수 있다.

  R은 컴퓨터 언어이자 다양한 패키지의 집합이다. 따라서 R 안에서 대부분의 데이터 분석을 해낼 수 있다는 장점이 있다. R은 통계, 기계 학습, 금융, 생물정보학, 그래픽스에 이르는 다양한 통계 패키지를 갖추고 있으며 이 모든 것이 무료로 제공된다. 이러한 다양한 패키지는 CRAN(http://cran.r-project.org/web/views/)을 통해 한곳에서 살펴볼 수 있다. 여기에 더해 최근 시류에 발맞춰 R은 멀티프로세서에서 손쉽게 병렬화하여 실행할 수 있고, RHive를 사용하면 최근 인기를 끌고 있는 Hive 환경에서 R을 사용할 수 있다.

  인기가 좋다는 것은 알겠는데, 그렇다고 꼭 R을 배워야 할까? 다른 언어 또는 환경은 없을까? 물론 다른 언어나 환경도 있다. WEKA는 자바로 작성한 데이터 마이닝 소프트웨어로, 자바 언어에서 연결해 사용하기에 편리하다. 또한, 매우 훌륭한 책[[2\]](https://thebook.io/006723/ch01/08/#ref2)이 나와 있어 쉽게 시작할 수 있는 환경이다. 그러나 WEKA는 기본적으로 GUI를 사용한 도구지 하나의 언어 체계는 아니다. 따라서 R의 CRAN처럼 여러 개발자가 기여하는 다양한 패키지는 없다.

  파이썬Python에는 데이터 분석을 위한 라이브러리들의 모음인 pydata(http://pydata.org/)가 있다. pydata에는 numpy(고속 연산), scipy(과학 분석 알고리즘), pandas(데이터의 표현 및 처리), matplotlib(시각화 도구), scikit-learn(기계 학습) 등의 다양한 라이브러리가 있다. <Python for Data Analysis>[[3\]](https://thebook.io/006723/ch01/08/#ref3)처럼 numpy, pandas 등을 잘 설명한 책도 있다. 그러나 pydata에는 R의 다양한 통계 기능에 대응하는 기능이 종종 빠져 있다. 이를 해결하기 위한 statsmodel 등의 라이브러리가 있지만 문서화 수준이 아주 빈약한 상태다.

  R이 좋은 이유에 대한 질문에 딱 하나만 답해야 한다면, 필자는 셀 수 없이 많은 R을 사용한 통계 분석 서적, 기계 학습 관련 서적을 들고 싶다. 기초부터 발전된 주제까지 포괄한 서적과 문서화 덕분에 이론과 실제를 동시에 배울 수 있는 환경이 가장 잘 갖춰져 있는 것이 R이다. 이론을 한껏 공부한 뒤에 구현은 따로 해야 한다거나, 구현은 있는데 이것이 어떻게 이론적으로 연결되는지를 별도로 공부해야 하는 상황에 처할 일이 없다.

  [ https://thebook.io/006723/ch01/ 참고]

- IDE를 사용하여 개발을 진행한다. RStudio를 사용

  - <설치 방법>

  - rstudio.com에 들어간다. 
  - download 들어가서 해당 컴퓨터 유형으로 다운로드 받는다 . 
  - 실행

##### RStudio

- 명령어 

  ~~~
  CTRL + L : 내용 삭제
  
  a <- 100 : 100값을 갖는 'a'
  
  ~~~

​        

- 실행 

  - Run : 라인 별로 실행 

  - Source : 디렉터리에 R파일/문서 전체 실행

    ```R
    source( 
      file  # 파일명
    )   
    ```

- install.packages : 패키지를 다운로드해서 설치한다. (console 창)

  ```bash
  install.packages(
    pkgs,         # 설치할 패키지명 
    dependencies  # 기본값은 NA , pkgs가 동작하는 데 필요한 패키지를 설치한다. TRUE는 패키지 제작자가 추천하는 패키지 역시 설치된다. 
  )
  ```

- library : 패키지를 로드하여 사용할 준비를 한다 (script 창)

  ```bash
  library(
    package,  # 사용할 패키지명
    help      # 패키지에 대한 도움말  
  )
  ```

  

> 다운로드 중 문제가 발생하면 repository를 다 삭제하고 다시 받는다 .



###### 변수

- 규칙 : R의 변수명은 알파벳, 숫자, _(언더스코어),.(마침표)로 구성되며 , -(하이픈)은 사용할 수 없다. 첫 글자는 알파벳 또는 .으로 시작하고 만약 .으로 시작한다면 . 뒤에는 숫자가 올 수 없다

- 값 할당 

​       <-, <<- 또는 = 연산자를 사용

```
a <- c(1:10);
b <- mean(a);
print(b)
```

> 1:10 은 1부터 10까지 나열
>
> mean은 "평균" 즉 중간값
>
> :alarm_clock:참고
>
> 할당 연산자 중 =는 명령의 최상위 수준에서만 사용할 수 있는 반면 <-는 어느 곳에서나 사용가능하다. 따라서 함수 호출과 동시에 변수에 값을 할당하려면 <-만 사용 가능 
>
> ```bash
>   > mean(x <- c(1, 2, 3))
>   [1] 2
>   > x
>   [1] 1 2 3
> ```
>
> 같은 상황에서 =를 사용하면 x에 값이 저장되지 않는다. 즉 이 차이 때문에 =를 사용하면 경우에 따라 표현력에 한계가 있을 수 있다.
>
> ```bash
>   > mean(x = c(1, 2, 3))
>   [1] 2
>   > x
>   Error: object 'x' not found
>   >
> ```

- 주석은 '#'

- 스칼라 :  단일 차원의 값을 뜻하는 것으로 숫자 1,2,3,...을 예로 들 수 있다. R에서 데이터 타입의 기본은 벡터Vector다

  ```bash
  > a <- 3
  > b <- 4.5
  > c <- a + b
  > print(c)
  [1] 7.5
  > c
  [1] 7.5
  >
  ```

  

- NA : 데이터 없음을 뜻한다. 

```bash
a <- 100;
b <- 200;
c <- NA;     #c는 값이 없음
print(is.na(c));
print(a+c)
```

> is.na  : NA 값이 저장되어 있는지를 판단

- NULL  : 객체를 뜻하며, 변수가 초기화되지 않았을 때 사용

```bash
a <- 100;
b <- 200;
d <- NULL;
print(is.null(d));
```

> is.null : 변수에 NULL이 저장되어 있는지를 판단

:star: NULL 과 NA의 차이 : NA는 결측지, 즉 값이 빠져있는 경우 결측치가 존재하는 이유로는 데이터 입력 중 실수로 값을 입력하지 않은 경우, 값을 어떤 이유로든 관찰되지 못한 경우(예를 들어, 인구 조사에서 특정 가구가 소득을 기재하지 않은 경우), 마지막으로 해당 항목에 적절한 값이 없어서 값이 입력되지 않은 경우(예를 들어, 약품의 냄새를 기록하고 있는 칸에서 특정 약품은 향이 없는 경우)를 들 수 있다.

반면 NULL은 프로그래밍의 편의를 위해 미정(undefined) 값을 표현하는 데 사용하는 개념이다. is_even이라는 변수에 a 변수의 값이 짝수면 TRUE, 홀수면 FALSE를 저장하는 다음 예를 보자.

```
  is_even <- NULL
  if (a 가 짝수면) {
     is_even <- TRUE
  } else {
     is_even <- FALSE
  }
```

위 코드에서 if 조건문이 실행되기 전에는 is_even에 어떤 값을 줘야 할지 알 수 없어 NULL로 초기화했다. 그리고 if 문을 지나면서 is_even에 적절한 값이 할당되었다. 이처럼 NULL은 변숫값이 아직 미정인 상태를 표현하는 목적으로 사용한다.

- 문자열
  - R에는 한 개 문자에 대한 데이터 타입이다. 대신 문자열로 모든 것을 표현 하며 문자열은 ‘ ’ 또는 “ ”과 같이 어느 따옴표로 묶어도 무관하다.

```bash
> a <- "hello"
> print(a)
[1] "hello"
> a <- 'hello'
> print(a)
[1] "hello"
```

- 진릿값

  - TRUE, T 는 모두 참 값을 의미한다. FALSE, F는 거짓 값을 의미한다. AND (&) , OR(|) , NOT(!) 연산자 사용 가능

- 팩터 :  범주형Categorical 데이터(자료)를 표현하기 위한 데이터 타입이다.

  범주형 데이터란 데이터가 사전에 정해진 특정 유형으로만 분류되는 경우를 뜻한다. 예를 들어, 방의 크기를 대, 중, 소로 나누어 기재하고 있을 때 특정 방의 크기를 ‘대’라고 적는다면 이 값은 범주형 데이터다. 이와 같이 범주형 변수가 담을 수 있는 값의 목록(이 예에서는 대, 중, 소)을 레벨(수준)level이라고 한다. 따라서 범주형 데이터를 저장하는 데이터 타입인 팩터에는 관측된 값뿐만 아니라 관측 가능한 값의 레벨도 나열해야 한다.

  - factor : 팩터 값을 생성한다.

    ```bash
    factor(
       X,       # 팩터로 표현하고자 하는 값(주로 문자열 벡터로 지정)
       levels,  # 값의 레벨
       ordered  # TRUE면 순서형, FALSE면 명목형 데이터를 뜻한다. 기본값은 FALSE>다.
    )
    ```

    

  - nlevels : 팩터에서 레벨의 개수를 반환한다.

    ```bash
    nlevels(
       x  # 팩터 값 
    )
    ```

    

  - levels : 팩터에서 레벨의 목록을 반환한다.

    ```bash
    levels(
       x  # 팩터 값 
    )
    ```

    

  - is.factor :  주어진 값이 팩터 인지를 판단한다.

    ```bash
    is.factor(
       x  # R 객체 
    )
    # 반환 값은 x가 팩터면 TRUE, 그렇지 않으면 FALSE다.
    ```

    

  - ordered : 순서형 팩터를 생성

    ```bash
    ordered(
       x  # 팩터로 표현하고자 하는 값(주로 문자열 벡터로 지정)
    )
    ```

    

  - is.ordered : 순서형 팩터인지를 판단

    ```bash
    is.ordered(
       x  # R 객체 
    )
    # 반환 값은 x가 팩터면 TRUE, 그렇지 않으면 FALSE다.
    ```

    :alarm_clock: 사용예시

    ``` bash
    data <- factor("m",c("m","f"));
    print(data)
    print(levels(data)[1])
    print(levels(data)[3])
    
    a <- c(1,3,5); #vector 즉 배열을 나타낸다.
    b <- c(1:5);
    c <- c(1,3,c(4:6));
    print(c)
    
    
    score <- c(100,90,80)
    names(score) <- c("lee","kim","han")
    print(score[1]) #vector의 컬럼이름 지
    print(sum(score)) #vector의 컬럼의 합 
    print(score["lee"]) 
    
    
    
    
    
    v1 <- c(10:20);
    print(v1[5:8]);#해당 범위의 값을 추출
    print(length(v1)) #vector 객체의길이
    print(NROW(v1)) # 배열의 행 또는 열의 수를 반환한다.
    
    
    
    
    v1 <- c(1:10);
    print(v1[1]);
    print(v1[-1])
    
    (Console)
    
    > data <- factor("m",c("m","f"));
    > print(data)
    [1] m
    Levels: m f
    > print(levels(data)[1])
    [1] "m"
    > print(levels(data)[3])
    [1] NA
    > 
    > a <- c(1,3,5); #vector 즉 배열을 나타낸다.
    > b <- c(1:5);
    > c <- c(1,3,c(4:6));
    > print(c)
    [1] 1 3 4 5 6
    > 
    > 
    > score <- c(100,90,80)
    > names(score) <- c("lee","kim","han")
    > print(score[1]) #vector의 컬럼이름 지
    lee 
    100 
    > print(sum(score)) #vector의 컬럼의 합 
    [1] 270
    > print(score["lee"]) 
    lee 
    100 
    > 
    ```

    > 참고) 예를 들어, 성별을 팩터로 만드는 경우를 생각해보자. 성별은 범주형 데이터 중 명목형 데이터에 해당하며, “m”(남성Male)과 “f”(여성Female) 두 가지 값이 가능하다. 따라서 남성을 저장한 변수 sex를 다음과 같이 생성할 수 있다.
    >
    > ```
    > > sex <- factor("m", c("m", "f"))
    > > sex
    > [1] m
    > Levels: m f
    > ```
    >
    > 위 코드에서 sex에는 “m”이 저장되었고, 이 팩터가 담을 수 있는 값의 레벨은 “m”, “f”로 제한되었다. c( )는 ‘2.4 벡터’ 절에서 설명할 벡터를 뜻하며, c(“m”, “f”)는 쉽게 “m”, “f”가 저장된 배열로 생각하면 된다.
    >
    > 팩터 변수는 nlevels( )로 레벨의 수를 알 수 있고, levels( )로 레벨의 목록을 볼 수 있다.
    >
    > ```
    > > nlevels(sex)
    > [1] 2
    > > levels(sex)
    > [1] "m" "f"
    > ```
    >
    > levels( )의 반환 값은 벡터며, 벡터는 다른 언어의 배열처럼 사용할 수 있다. 따라서 각 레벨의 값을 다음과 같이 구할 수 있다. R에서 색인(인덱스)Index은 0이 아닌 1부터 시작한다는 점에 유의하기 바란다.
    >
    > ```
    > > levels(sex)[1]
    > [1] "m"
    > > levels(sex)[2]
    > [1] "f"
    > ```
    >
    > 팩터 변수에서 레벨 값을 직접 수정하고자 한다면 levels( )에 값을 할당하면 된다. “m”을 “male”로, “f”를 “female”로 바꿔보자.
    >
    > ```
    > > sex
    > [1] m
    > Levels: m f
    > > levels(sex) <- c("male", "female")
    > > sex
    > [1] male
    > Levels: male female
    > ```
    >
    > 여러 개의 값을 팩터로 만들고자 한다면 factor( )의 인자 x에 벡터를 지정한다.
    >
    > ```
    > > factor(c("m", "m", "f"), c("m", "f"))
    > [1] m m f
    > Levels: m f
    > ```
    >
    > levels 인자를 생략하면 데이터로부터 자동으로 레벨의 목록을 파악한다.
    >
    > ```
    > > factor(c("m", "m", "f"))
    > [1] m m f
    > Levels: f m
    > ```
    >
    > factor( )는 기본적으로 데이터에 순서가 없는 명목형 데이터를 만든다. 순서형 데이터를 원한다면 ordered( )를 사용하거나 factor( ) 호출 시 ordered=TRUE를 지정한다.
    >
    > ```bash
    > > ordered("a", c("a", "b", "c"))
    > [1] a
    > Levels: a < b < c
    > ```

- 백터 연산 

  - identical : 객체가 동일한지를 판단

    ```bash
    > identical(c(1, 2, 3), c(1, 2, 3))
    [1] TRUE
    > identical(c(1, 2, 3), c(1, 2, 100))
    [1] FALSE
    ```

    > %in% 연산자는 어떤 값이 벡터에 포함되어 있는지를 알려준다.
    >
    > ```bash
    > > "a" %in% c("a", "b", "c")
    > [1] TRUE
    > > "d" %in% c("a", "b", "c")
    > [1] FALSE
    > ```
    >
    > :alarm_clock: 벡터 전체 값으로 연산을 한번에 수행 가능
    >
    > ```bash
    > > x <- c(1, 2, 3, 4, 5)
    > > x + 1
    > [1] 2 3 4 5 6
    > > 10 - x
    > [1] 9 8 7 6 5
    > ```
    >
    > :alarm_clock: 벡터 전체로 == 또는 != 연산자를 사용할 수 있다.그러나 흔히 if 문 등의 조건문에서는 단 하나의 참 또는 거짓 값을 사용해야 하기 때문에 ==, !=가 아니라 앞서 설명한 identical( )을 사용해야 한다.
    >
    > ```bash
    > > c(1, 2, 3) == c(1, 2, 100)
    > [1] TRUE TRUE FALSE
    > > c(1, 2, 3) != c(1, 2, 100)
    > [1] FALSE FALSE TRUE
    > ```
    >
    > 

  - union : 합집합을 구한다.

    ```bash
    > union (c("a", "b", "c"), c("a", "d"))      # 합집합 
    [1] "a" "b" "c" "d"
    ```

    

  - intersect : 교집합을 구한다.

    ```bash
    > intersect (c("a", "b", "c"), c("a", "d"))  # 교집합
    [1] "a"
    ```

    

  - setdiff : 차집합을 구한다.

    ```bash
    > setdiff (c("a", "b", "c"), c("a", "d"))    # 차집합
    [1] "b" "c"
    ```

    

  - setequal : x 와 y가 같은 집합인지 판단. (집합요소들이 같은지!)

    ```bash
    > setequal (c("a", "b", "c"), c("a", "d"))
    [1] FALSE
    > setequal (c("a", "b", "c"), c("a", "b", "c", "c"))
    [1] TRUE
    ```

    

  - 벡터 연산자

    - | 연산자       | 의미                                                         |
      | ------------ | ------------------------------------------------------------ |
      | value %in% x | 벡터 x에 value가 저장되어 있는지 판단함                      |
      | x + n        | 벡터 x의 모든 요소에 n을 더한 벡터를 구함. 마찬가지로 *, /, -, == 등의 연산자를 적용 가능함 |

  - 연속된 숫자로 구성된 벡터

    - seq : 시퀀스를 생성한다. (증가치를 설정 가능 !!)

      ```bash
      seq(
        from,  # 시작 값 
        to,    # 끝 값 
        by     # 증가치 
      )
      
      a <- c(1:10) #1부터 10 까지 나열
      b <- seq(1,10,2) #1부터 10까지 2씩 증가하면서 나열
      print(a)
      print(b)
      
      ```

> ​                :blue_car: seq_along : 주어진 객체의 길이만큼 시퀀스를 생성한다.
>
> ​				
>
> ```bash
> seq_along(
>   along.with  # 이 인자 길이만큼 시퀀스를 생성한다. 
> ) #반환 값은 along.with의 길이가 N일 때, 1부터 N까지의 숫자를 저장한 벡터다.
> ```
>
> | 문법     | 의미                                                         |
> | -------- | ------------------------------------------------------------ |
> | from:end | from부터 end까지의 숫자를 저장한 벡터를 반환함(from과 end 포함) |
>
> 1씩 증가 또는 감소하는 벡터의 경우 seq( )를 사용하지 않고 ‘start:end’ 형태의 축약형으로도 표현할 수 있다.
>
> ```bash
> > 3:7
> [1] 3 4 5 6 7
> > 7:3
> [1] 7 6 5 4 3
> ```
>
> 1부터 주어진 벡터의 길이 N까지의 값을 저장한 색인 벡터가 필요한 경우 NROW( )로 길이를 얻어 색인 벡터를 만들 수 있다. 또는 seq_along(x)를 사용해 x의 길이까지의 값을 담은 벡터를 생성할 수 있다.
>
> ```bash
> > x <- c(2, 4, 6, 8, 10)
> > 1:NROW(x)
> [1] 1 2 3 4 5
> > seq_along(x)
> [1] 1 2 3 4 5
> ```
>
> 

- 반복된 값을 거장한 벡터

  - 반복된 값을 저장한 벡터는 c(1, 1, 1, 1, 2, 2, 2, 2) 또는 c(1, 2, 1, 2, 1, 2, 1, 2)처럼 숫자가 반복되는 형태로 나타나는 벡터를 뜻한다. 이러한 벡터를 색인 벡터로 사용하면 주어진 데이터를 몇 개 분류로 쉽게 나눌 수 있어 종종 사용한다. 반복된 값이 저장된 벡터는 rep( )로 생성할 수 있다. (rep : 주어진 값을 반복한다.)

    ```bash
    rep(
       x,      # 반복할 값이 저장된 벡터 
       times,  # 전체 벡터의 반복 횟수 
       each    # 개별 값의 반복 횟수 
    )
    
    > rep(1:2, times=5)
    [1] 1 2 1 2 1 2 1 2 1 2
    
    > rep(1:2, each=5)
    [1] 1 1 1 1 1 2 2 2 2 2
    
    > rep(1:2, each=5, times=2)
    [1] 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 2 2 2 2
    ```

    











##### 리스트

- 리스트는 ‘(키, 값)’ 형태의 데이터를 담는 연관 배열Associative Array이다.

- list() 함수를 사용해 생성

  - list : 리스트 객체 생성 

    ```bash
    a <- list(name=c("a","b","c","d"), score=c(90,100,80,30))
    print(a)
    
    (Console)
    > print(a)
    $name
    [1] "a" "b" "c" "d"
    
    $score
    [1]  90 100  80  30
    ```

    :blue_car:사용 예시 )

    ```bash
    a <- list(s1=c(80,90,70,88), s2=c(90,100,80,30))
    print(a)
    print(mean(c(a$s1[1],a$s1[4]))) #해당 s1 1번째와 4번째의 평균 a$s1[c(1,4)] 도 가능
    print(mean(c(a$s2[1],a$s2[4])))  #해당 s2 1번째와 4번째의 평균 a$s2[c(1,4)] 도 가능
    print(mean(a$s1[c(1:3)])) #해당 s1에 1부터 3번째 까지의 평균
    d1 <- mean(a$s1)
    d2 <- mean(a$s2)
    
    print(d1)
    print(d2)
    print(mean(c(d1,d2)))
    
    print(a)
    print(mean(a$s1)) #a$s1 : vector
    print(mean(a$s2))
    print(mean(c(mean(a$s1),mean(a$s2))))
    
    print(a)
    print(mean(c(a$s1[1],a$s1[4]))) #a$s1 : vector
    print(mean(a$s2[4]))
    print(mean(c(mean(a$s1),mean(a$s2))))
    
    
    (Console)
    > print(a)
    $s1
    [1] 80 90 70 88
    
    $s2
    [1]  90 100  80  30
    
    > print(mean(a$s1)) #a$s1 : vector
    [1] 82
    > print(mean(a$s2))
    [1] 75
    > print(mean(c(mean(a$s1),mean(a$s2))))
    [1] 78.5
    > 
    > print(a)
    $s1
    [1] 80 90 70 88
    
    $s2
    [1]  90 100  80  30
    
    > print(mean(c(a$s1[1],a$s1[4]))) #a$s1 : vector
    [1] 84
    > print(mean(a$s2[4]))
    [1] 30
    > print(mean(c(mean(a$s1),mean(a$s2))))
    [1] 78.5
    > 
    
    
    
    
    ```

    > 참고) 
    >
    > 다음은 name에 “foo”, height에 70을 저장하는 리스트를 보여준다.
    >
    > ```
    > > (x <- list(name="foo", height=70))
    > $ name
    > [1] "foo"
    > 
    > $ height
    > [1] 70
    > ```
    >
    > 이때 각 값이 반드시 스칼라일 필요는 없다. 다음처럼 벡터를 저장할 수도 있다.
    >
    > ```
    > > (x <- list(name="foo", height=c(1, 3, 5)))
    > $ name
    > [1] "foo"
    > 
    > $ height
    > [1] 1 3 5
    > ```
    >
    > 이처럼 리스트에는 다양한 값을 혼합해서 저장할 수 있다. 따라서 리스트 안에 리스트를 중첩하는 일도 가능하다.
    >
    > ```bash
    > > list (a=list(val=c(1, 2, 3)), b=list(val=c(1, 2, 3, 4)))
    > $a
    > $a$val
    > [1] 1 2 3
    > 
    > 
    > $b
    > $b$val
    > [1] 1 2 3 4
    > ```

​      

- 리스트 데이터 접근

  리스트에 저장된 데이터는 색인 또는 키를 사용해 접근할 수 있다.

  ▼ **표 2-13** 리스트 데이터 접근 문법

  | 문법  | 의미                                   |
  | ----- | -------------------------------------- |
  | x$key | 리스트 x에서 키 값 key에 해당하는 값   |
  | x[n]  | 리스트 x에서 n번째 데이터의 서브리스트 |
  | x     | 리스트 x에서 n번째 저장된 값           |

  앞에서 살펴본 것처럼 리스트를 출력해보면 ‘$키’ 형태로 각 키가 나열된다. 데이터는 ‘x$key’ 형태로 접근한다. 또는 각 요소를 순서대로 x 형태로 접근할 수도 있다.

  ```bash
  > x <- list(name="foo", height=c(1, 3, 5))
  > x$name
  [1] "foo"
  > x$height
  [1] 1 3 5
  > x1
  [1] "foo"
  > x2
  [1] 1 3 5
  ```

  x과 달리 x[n] 형태는 각 값이 아니라 ‘(키, 값)’을 담고 있는 서브리스트를 반환한다. 예를 들어, 다음 코드를 보자.

  ```bash
  > x[1]
  $ name
  [1] "foo"
  > x[2]
  $ height
  [1] 1 3 5
  ```

  코드에서 볼 수 있듯이 x[1]은 (name, “foo”)를 담고 있는 리스트다.

##### 행렬

- 한 가지 타입이 들어간다. 

##### :star: 데이터 프레임

- 처리할 데이터 마치 엑셀의 스프레드시트와 같이 표 형태로 정리한 모습을 하고 있다. 
- 다양한 타입이 들어 간다.
-  R에서 가장 중요한 데이터 타입이며, 많은 R 함수에서 인자로 데이터 프레임을 받는다.
- 생성 )
  -  data.frame : 데이터 프레임을 생성한다.

