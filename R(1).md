## R

- 온라인 서적 : https://thebook.io/006723/ch01/

##### 

- ## 왜 R인가

  R[[1\]](https://thebook.io/006723/ch01/08/#ref1)은 데이터 분석을 위한 통계 및 그래픽스를 지원하는 자유 소프트웨어 환경이다. 

  R은 현재 데이터 분석을 위한 도구로 많은 인기를 누리고 있다. 한 가지 사례로 데이터 마이닝data mining이나 기계 학습machine learning에 대한 소식을 공유하는 사이트인 kdnugget에서 실시한 ‘지난 12개월간 실제로 사용한 분석, 데이터 마이닝, 빅데이터 소프트웨어’에 대한 설문 조사를 볼 수 있다. 그 내용에 따르면 래피드 마이너Rapid Miner, 웨카Weka, SAS, 매트랩MATLAB 등의 쟁쟁한 경쟁자와 비교했을 때 R은 2012년에 1위, 2013년에 2위를 차지해 그 인기가 높음을 알 수 있다.

  R은 컴퓨터 언어이자 다양한 패키지의 집합이다. 따라서 R 안에서 대부분의 데이터 분석을 해낼 수 있다는 장점이 있다. R은 통계, 기계 학습, 금융, 생물정보학, 그래픽스에 이르는 다양한 통계 패키지를 갖추고 있으며 이 모든 것이 무료로 제공된다. 이러한 다양한 패키지는 CRAN(http://cran.r-project.org/web/views/)을 통해 한곳에서 살펴볼 수 있다. 여기에 더해 최근 시류에 발맞춰 R은 멀티프로세서에서 손쉽게 병렬화하여 실행할 수 있고, RHive를 사용하면 최근 인기를 끌고 있는 Hive 환경에서 R을 사용할 수 있다.

  인기가 좋다는 것은 알겠는데, 그렇다고 꼭 R을 배워야 할까? 다른 언어 또는 환경은 없을까? 물론 다른 언어나 환경도 있다. WEKA는 자바로 작성한 데이터 마이닝 소프트웨어로, 자바 언어에서 연결해 사용하기에 편리하다. 또한, 매우 훌륭한 책[[2\]](https://thebook.io/006723/ch01/08/#ref2)이 나와 있어 쉽게 시작할 수 있는 환경이다. 그러나 WEKA는 기본적으로 GUI를 사용한 도구지 하나의 언어 체계는 아니다. 따라서 R의 CRAN처럼 여러 개발자가 기여하는 다양한 패키지는 없다.

  파이썬Python에는 데이터 분석을 위한 라이브러리들의 모음인 pydata(http://pydata.org/)가 있다. pydata에는 numpy(고속 연산), scipy(과학 분석 알고리즘), pandas(데이터의 표현 및 처리), matplotlib(시각화 도구), scikit-learn(기계 학습) 등의 다양한 라이브러리가 있다. <Python for Data Analysis>[[3\]](https://thebook.io/006723/ch01/08/#ref3)처럼 numpy, pandas 등을 잘 설명한 책도 있다. 그러나 pydata에는 R의 다양한 통계 기능에 대응하는 기능이 종종 빠져 있다. 이를 해결하기 위한 statsmodel 등의 라이브러리가 있지만 문서화 수준이 아주 빈약한 상태다.

  R이 좋은 이유에 대한 질문에 딱 하나만 답해야 한다면, 필자는 셀 수 없이 많은 R을 사용한 통계 분석 서적, 기계 학습 관련 서적을 들고 싶다. 기초부터 발전된 주제까지 포괄한 서적과 문서화 덕분에 이론과 실제를 동시에 배울 수 있는 환경이 가장 잘 갖춰져 있는 것이 R이다. 이론을 한껏 공부한 뒤에 구현은 따로 해야 한다거나, 구현은 있는데 이것이 어떻게 이론적으로 연결되는지를 별도로 공부해야 하는 상황에 처할 일이 없다.

  [ https://thebook.io/006723/ch01/ 참고]

- IDE를 사용하여 개발을 진행한다. RStudio를 사용

  - <설치 방법>

  - rstudio.com에 들어간다. 
  - download 들어가서 해당 컴퓨터 유형으로 다운로드 받는다 . 
  - 실행

##### RStudio

- 명령어 

  ~~~
  CTRL + L : 내용 삭제
  
  a <- 100 : 100값을 갖는 'a'
  
  ~~~

​        

- 실행 

  - Run : 라인 별로 실행 

  - Source : 디렉터리에 R파일/문서 전체 실행

    ```R
    source( 
      file  # 파일명
    )   
    ```

- install.packages : 패키지를 다운로드해서 설치한다. (console 창)

  ```bash
  install.packages(
    pkgs,         # 설치할 패키지명 
    dependencies  # 기본값은 NA , pkgs가 동작하는 데 필요한 패키지를 설치한다. TRUE는 패키지 제작자가 추천하는 패키지 역시 설치된다. 
  )
  ```

- library : 패키지를 로드하여 사용할 준비를 한다 (script 창)

  ```bash
  library(
    package,  # 사용할 패키지명
    help      # 패키지에 대한 도움말  
  )
  ```

  

> 다운로드 중 문제가 발생하면 repository를 다 삭제하고 다시 받는다 .



###### 변수

- 규칙 : R의 변수명은 알파벳, 숫자, _(언더스코어),.(마침표)로 구성되며 , -(하이픈)은 사용할 수 없다. 첫 글자는 알파벳 또는 .으로 시작하고 만약 .으로 시작한다면 . 뒤에는 숫자가 올 수 없다

- 값 할당 

​       <-, <<- 또는 = 연산자를 사용

```
a <- c(1:10);
b <- mean(a);
print(b)
```

> 1:10 은 1부터 10까지 나열
>
> mean은 "평균" 즉 중간값
>
> :alarm_clock:참고
>
> 할당 연산자 중 =는 명령의 최상위 수준에서만 사용할 수 있는 반면 <-는 어느 곳에서나 사용가능하다. 따라서 함수 호출과 동시에 변수에 값을 할당하려면 <-만 사용 가능 
>
> ```bash
>   > mean(x <- c(1, 2, 3))
>   [1] 2
>   > x
>   [1] 1 2 3
> ```
>
> 같은 상황에서 =를 사용하면 x에 값이 저장되지 않는다. 즉 이 차이 때문에 =를 사용하면 경우에 따라 표현력에 한계가 있을 수 있다.
>
> ```bash
>   > mean(x = c(1, 2, 3))
>   [1] 2
>   > x
>   Error: object 'x' not found
>   >
> ```

- 주석은 '#'

- 스칼라 :  단일 차원의 값을 뜻하는 것으로 숫자 1,2,3,...을 예로 들 수 있다. R에서 데이터 타입의 기본은 벡터Vector다

  ```bash
  > a <- 3
  > b <- 4.5
  > c <- a + b
  > print(c)
  [1] 7.5
  > c
  [1] 7.5
  >
  ```

  

- NA : 데이터 없음을 뜻한다. 

```bash
a <- 100;
b <- 200;
c <- NA;     #c는 값이 없음
print(is.na(c));
print(a+c)
```

> is.na  : NA 값이 저장되어 있는지를 판단

- NULL  : 객체를 뜻하며, 변수가 초기화되지 않았을 때 사용

```bash
a <- 100;
b <- 200;
d <- NULL;
print(is.null(d));
```

> is.null : 변수에 NULL이 저장되어 있는지를 판단

:star: NULL 과 NA의 차이 : NA는 결측지, 즉 값이 빠져있는 경우 결측치가 존재하는 이유로는 데이터 입력 중 실수로 값을 입력하지 않은 경우, 값을 어떤 이유로든 관찰되지 못한 경우(예를 들어, 인구 조사에서 특정 가구가 소득을 기재하지 않은 경우), 마지막으로 해당 항목에 적절한 값이 없어서 값이 입력되지 않은 경우(예를 들어, 약품의 냄새를 기록하고 있는 칸에서 특정 약품은 향이 없는 경우)를 들 수 있다.

반면 NULL은 프로그래밍의 편의를 위해 미정(undefined) 값을 표현하는 데 사용하는 개념이다. is_even이라는 변수에 a 변수의 값이 짝수면 TRUE, 홀수면 FALSE를 저장하는 다음 예를 보자.

```
  is_even <- NULL
  if (a 가 짝수면) {
     is_even <- TRUE
  } else {
     is_even <- FALSE
  }
```

위 코드에서 if 조건문이 실행되기 전에는 is_even에 어떤 값을 줘야 할지 알 수 없어 NULL로 초기화했다. 그리고 if 문을 지나면서 is_even에 적절한 값이 할당되었다. 이처럼 NULL은 변숫값이 아직 미정인 상태를 표현하는 목적으로 사용한다.

- 문자열
  - R에는 한 개 문자에 대한 데이터 타입이다. 대신 문자열로 모든 것을 표현 하며 문자열은 ‘ ’ 또는 “ ”과 같이 어느 따옴표로 묶어도 무관하다.

```bash
> a <- "hello"
> print(a)
[1] "hello"
> a <- 'hello'
> print(a)
[1] "hello"
```

- 진릿값

  - TRUE, T 는 모두 참 값을 의미한다. FALSE, F는 거짓 값을 의미한다. AND (&) , OR(|) , NOT(!) 연산자 사용 가능

- 팩터 :  범주형Categorical 데이터(자료)를 표현하기 위한 데이터 타입이다.

  범주형 데이터란 데이터가 사전에 정해진 특정 유형으로만 분류되는 경우를 뜻한다. 예를 들어, 방의 크기를 대, 중, 소로 나누어 기재하고 있을 때 특정 방의 크기를 ‘대’라고 적는다면 이 값은 범주형 데이터다. 이와 같이 범주형 변수가 담을 수 있는 값의 목록(이 예에서는 대, 중, 소)을 레벨(수준)level이라고 한다. 따라서 범주형 데이터를 저장하는 데이터 타입인 팩터에는 관측된 값뿐만 아니라 관측 가능한 값의 레벨도 나열해야 한다.

  - factor : 팩터 값을 생성한다.

    ```bash
    factor(
       X,       # 팩터로 표현하고자 하는 값(주로 문자열 벡터로 지정)
       levels,  # 값의 레벨
       ordered  # TRUE면 순서형, FALSE면 명목형 데이터를 뜻한다. 기본값은 FALSE>다.
    )
    ```

    

  - nlevels : 팩터에서 레벨의 개수를 반환한다.

    ```bash
    nlevels(
       x  # 팩터 값 
    )
    ```

    

  - levels : 팩터에서 레벨의 목록을 반환한다.

    ```bash
    levels(
       x  # 팩터 값 
    )
    ```

    

  - is.factor :  주어진 값이 팩터 인지를 판단한다.

    ```bash
    is.factor(
       x  # R 객체 
    )
    # 반환 값은 x가 팩터면 TRUE, 그렇지 않으면 FALSE다.
    ```

    

  - ordered : 순서형 팩터를 생성

    ```bash
    ordered(
       x  # 팩터로 표현하고자 하는 값(주로 문자열 벡터로 지정)
    )
    ```

    

  - is.ordered : 순서형 팩터인지를 판단

    ```bash
    is.ordered(
       x  # R 객체 
    )
    # 반환 값은 x가 팩터면 TRUE, 그렇지 않으면 FALSE다.
    ```

    :alarm_clock: 사용예시

    ``` bash
    data <- factor("m",c("m","f"));
    print(data)
    print(levels(data)[1])
    print(levels(data)[3])
    
    a <- c(1,3,5); #vector 즉 배열을 나타낸다.
    b <- c(1:5);
    c <- c(1,3,c(4:6));
    print(c)
    
    
    score <- c(100,90,80)
    names(score) <- c("lee","kim","han")
    print(score[1]) #vector의 컬럼이름 지
    print(sum(score)) #vector의 컬럼의 합 
    print(score["lee"]) 
    
    
    
    
    
    v1 <- c(10:20);
    print(v1[5:8]);#해당 범위의 값을 추출
    print(length(v1)) #vector 객체의길이
    print(NROW(v1)) # 배열의 행 또는 열의 수를 반환한다.
    
    
    
    
    v1 <- c(1:10);
    print(v1[1]);
    print(v1[-1])
    
    (Console)
    
    > data <- factor("m",c("m","f"));
    > print(data)
    [1] m
    Levels: m f
    > print(levels(data)[1])
    [1] "m"
    > print(levels(data)[3])
    [1] NA
    > 
    > a <- c(1,3,5); #vector 즉 배열을 나타낸다.
    > b <- c(1:5);
    > c <- c(1,3,c(4:6));
    > print(c)
    [1] 1 3 4 5 6
    > 
    > 
    > score <- c(100,90,80)
    > names(score) <- c("lee","kim","han")
    > print(score[1]) #vector의 컬럼이름 지
    lee 
    100 
    > print(sum(score)) #vector의 컬럼의 합 
    [1] 270
    > print(score["lee"]) 
    lee 
    100 
    > 
    ```

    > 참고) 예를 들어, 성별을 팩터로 만드는 경우를 생각해보자. 성별은 범주형 데이터 중 명목형 데이터에 해당하며, “m”(남성Male)과 “f”(여성Female) 두 가지 값이 가능하다. 따라서 남성을 저장한 변수 sex를 다음과 같이 생성할 수 있다.
    >
    > ```
    > > sex <- factor("m", c("m", "f"))
    > > sex
    > [1] m
    > Levels: m f
    > ```
    >
    > 위 코드에서 sex에는 “m”이 저장되었고, 이 팩터가 담을 수 있는 값의 레벨은 “m”, “f”로 제한되었다. c( )는 ‘2.4 벡터’ 절에서 설명할 벡터를 뜻하며, c(“m”, “f”)는 쉽게 “m”, “f”가 저장된 배열로 생각하면 된다.
    >
    > 팩터 변수는 nlevels( )로 레벨의 수를 알 수 있고, levels( )로 레벨의 목록을 볼 수 있다.
    >
    > ```
    > > nlevels(sex)
    > [1] 2
    > > levels(sex)
    > [1] "m" "f"
    > ```
    >
    > levels( )의 반환 값은 벡터며, 벡터는 다른 언어의 배열처럼 사용할 수 있다. 따라서 각 레벨의 값을 다음과 같이 구할 수 있다. R에서 색인(인덱스)Index은 0이 아닌 1부터 시작한다는 점에 유의하기 바란다.
    >
    > ```
    > > levels(sex)[1]
    > [1] "m"
    > > levels(sex)[2]
    > [1] "f"
    > ```
    >
    > 팩터 변수에서 레벨 값을 직접 수정하고자 한다면 levels( )에 값을 할당하면 된다. “m”을 “male”로, “f”를 “female”로 바꿔보자.
    >
    > ```
    > > sex
    > [1] m
    > Levels: m f
    > > levels(sex) <- c("male", "female")
    > > sex
    > [1] male
    > Levels: male female
    > ```
    >
    > 여러 개의 값을 팩터로 만들고자 한다면 factor( )의 인자 x에 벡터를 지정한다.
    >
    > ```
    > > factor(c("m", "m", "f"), c("m", "f"))
    > [1] m m f
    > Levels: m f
    > ```
    >
    > levels 인자를 생략하면 데이터로부터 자동으로 레벨의 목록을 파악한다.
    >
    > ```
    > > factor(c("m", "m", "f"))
    > [1] m m f
    > Levels: f m
    > ```
    >
    > factor( )는 기본적으로 데이터에 순서가 없는 명목형 데이터를 만든다. 순서형 데이터를 원한다면 ordered( )를 사용하거나 factor( ) 호출 시 ordered=TRUE를 지정한다.
    >
    > ```bash
    > > ordered("a", c("a", "b", "c"))
    > [1] a
    > Levels: a < b < c
    > ```

- 백터 연산 

  - identical : 객체가 동일한지를 판단

    ```bash
    > identical(c(1, 2, 3), c(1, 2, 3))
    [1] TRUE
    > identical(c(1, 2, 3), c(1, 2, 100))
    [1] FALSE
    ```

    > %in% 연산자는 어떤 값이 벡터에 포함되어 있는지를 알려준다.
    >
    > ```bash
    > > "a" %in% c("a", "b", "c")
    > [1] TRUE
    > > "d" %in% c("a", "b", "c")
    > [1] FALSE
    > ```
    >
    > :alarm_clock: 벡터 전체 값으로 연산을 한번에 수행 가능
    >
    > ```bash
    > > x <- c(1, 2, 3, 4, 5)
    > > x + 1
    > [1] 2 3 4 5 6
    > > 10 - x
    > [1] 9 8 7 6 5
    > ```
    >
    > :alarm_clock: 벡터 전체로 == 또는 != 연산자를 사용할 수 있다.그러나 흔히 if 문 등의 조건문에서는 단 하나의 참 또는 거짓 값을 사용해야 하기 때문에 ==, !=가 아니라 앞서 설명한 identical( )을 사용해야 한다.
    >
    > ```bash
    > > c(1, 2, 3) == c(1, 2, 100)
    > [1] TRUE TRUE FALSE
    > > c(1, 2, 3) != c(1, 2, 100)
    > [1] FALSE FALSE TRUE
    > ```
    >
    > 

  - union : 합집합을 구한다.

    ```bash
    > union (c("a", "b", "c"), c("a", "d"))      # 합집합 
    [1] "a" "b" "c" "d"
    ```

    

  - intersect : 교집합을 구한다.

    ```bash
    > intersect (c("a", "b", "c"), c("a", "d"))  # 교집합
    [1] "a"
    ```

    

  - setdiff : 차집합을 구한다.

    ```bash
    > setdiff (c("a", "b", "c"), c("a", "d"))    # 차집합
    [1] "b" "c"
    ```

    

  - setequal : x 와 y가 같은 집합인지 판단. (집합요소들이 같은지!)

    ```bash
    > setequal (c("a", "b", "c"), c("a", "d"))
    [1] FALSE
    > setequal (c("a", "b", "c"), c("a", "b", "c", "c"))
    [1] TRUE
    ```

    

  - 벡터 연산자

    - | 연산자       | 의미                                                         |
      | ------------ | ------------------------------------------------------------ |
      | value %in% x | 벡터 x에 value가 저장되어 있는지 판단함                      |
      | x + n        | 벡터 x의 모든 요소에 n을 더한 벡터를 구함. 마찬가지로 *, /, -, == 등의 연산자를 적용 가능함 |

  - 연속된 숫자로 구성된 벡터

    - seq : 시퀀스를 생성한다. (증가치를 설정 가능 !!)

      ```bash
      seq(
        from,  # 시작 값 
        to,    # 끝 값 
        by     # 증가치 
      )
      
      a <- c(1:10) #1부터 10 까지 나열
      b <- seq(1,10,2) #1부터 10까지 2씩 증가하면서 나열
      print(a)
      print(b)
      
      ```

> ​                :blue_car: seq_along : 주어진 객체의 길이만큼 시퀀스를 생성한다.
>
> ​				
>
> ```bash
> seq_along(
>   along.with  # 이 인자 길이만큼 시퀀스를 생성한다. 
> ) #반환 값은 along.with의 길이가 N일 때, 1부터 N까지의 숫자를 저장한 벡터다.
> ```
>
> | 문법     | 의미                                                         |
> | -------- | ------------------------------------------------------------ |
> | from:end | from부터 end까지의 숫자를 저장한 벡터를 반환함(from과 end 포함) |
>
> 1씩 증가 또는 감소하는 벡터의 경우 seq( )를 사용하지 않고 ‘start:end’ 형태의 축약형으로도 표현할 수 있다.
>
> ```bash
> > 3:7
> [1] 3 4 5 6 7
> > 7:3
> [1] 7 6 5 4 3
> ```
>
> 1부터 주어진 벡터의 길이 N까지의 값을 저장한 색인 벡터가 필요한 경우 NROW( )로 길이를 얻어 색인 벡터를 만들 수 있다. 또는 seq_along(x)를 사용해 x의 길이까지의 값을 담은 벡터를 생성할 수 있다.
>
> ```bash
> > x <- c(2, 4, 6, 8, 10)
> > 1:NROW(x)
> [1] 1 2 3 4 5
> > seq_along(x)
> [1] 1 2 3 4 5
> ```
>
> 

- 반복된 값을 거장한 벡터

  - 반복된 값을 저장한 벡터는 c(1, 1, 1, 1, 2, 2, 2, 2) 또는 c(1, 2, 1, 2, 1, 2, 1, 2)처럼 숫자가 반복되는 형태로 나타나는 벡터를 뜻한다. 이러한 벡터를 색인 벡터로 사용하면 주어진 데이터를 몇 개 분류로 쉽게 나눌 수 있어 종종 사용한다. 반복된 값이 저장된 벡터는 rep( )로 생성할 수 있다. (rep : 주어진 값을 반복한다.)

    ```bash
    rep(
       x,      # 반복할 값이 저장된 벡터 
       times,  # 전체 벡터의 반복 횟수 
       each    # 개별 값의 반복 횟수 
    )
    
    > rep(1:2, times=5)
    [1] 1 2 1 2 1 2 1 2 1 2
    
    > rep(1:2, each=5)
    [1] 1 1 1 1 1 2 2 2 2 2
    
    > rep(1:2, each=5, times=2)
    [1] 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 2 2 2 2
    ```

    











##### 리스트

- 리스트는 ‘(키, 값)’ 형태의 데이터를 담는 연관 배열Associative Array이다.

- list() 함수를 사용해 생성

  - list : 리스트 객체 생성 

    ```bash
    a <- list(name=c("a","b","c","d"), score=c(90,100,80,30))
    print(a)
    
    (Console)
    > print(a)
    $name
    [1] "a" "b" "c" "d"
    
    $score
    [1]  90 100  80  30
    ```

    :blue_car:사용 예시 )

    ```bash
    a <- list(s1=c(80,90,70,88), s2=c(90,100,80,30))
    print(a)
    print(mean(c(a$s1[1],a$s1[4]))) #해당 s1 1번째와 4번째의 평균 a$s1[c(1,4)] 도 가능
    print(mean(c(a$s2[1],a$s2[4])))  #해당 s2 1번째와 4번째의 평균 a$s2[c(1,4)] 도 가능
    print(mean(a$s1[c(1:3)])) #해당 s1에 1부터 3번째 까지의 평균
    d1 <- mean(a$s1)
    d2 <- mean(a$s2)
    
    print(d1)
    print(d2)
    print(mean(c(d1,d2)))
    
    print(a)
    print(mean(a$s1)) #a$s1 : vector
    print(mean(a$s2))
    print(mean(c(mean(a$s1),mean(a$s2))))
    
    print(a)
    print(mean(c(a$s1[1],a$s1[4]))) #a$s1 : vector
    print(mean(a$s2[4]))
    print(mean(c(mean(a$s1),mean(a$s2))))
    
    
    (Console)
    > print(a)
    $s1
    [1] 80 90 70 88
    
    $s2
    [1]  90 100  80  30
    
    > print(mean(a$s1)) #a$s1 : vector
    [1] 82
    > print(mean(a$s2))
    [1] 75
    > print(mean(c(mean(a$s1),mean(a$s2))))
    [1] 78.5
    > 
    > print(a)
    $s1
    [1] 80 90 70 88
    
    $s2
    [1]  90 100  80  30
    
    > print(mean(c(a$s1[1],a$s1[4]))) #a$s1 : vector
    [1] 84
    > print(mean(a$s2[4]))
    [1] 30
    > print(mean(c(mean(a$s1),mean(a$s2))))
    [1] 78.5
    > 
    
    
    
    
    ```

    > 참고) 
    >
    > 다음은 name에 “foo”, height에 70을 저장하는 리스트를 보여준다.
    >
    > ```
    > > (x <- list(name="foo", height=70))
    > $ name
    > [1] "foo"
    > 
    > $ height
    > [1] 70
    > ```
    >
    > 이때 각 값이 반드시 스칼라일 필요는 없다. 다음처럼 벡터를 저장할 수도 있다.
    >
    > ```
    > > (x <- list(name="foo", height=c(1, 3, 5)))
    > $ name
    > [1] "foo"
    > 
    > $ height
    > [1] 1 3 5
    > ```
    >
    > 이처럼 리스트에는 다양한 값을 혼합해서 저장할 수 있다. 따라서 리스트 안에 리스트를 중첩하는 일도 가능하다.
    >
    > ```bash
    > > list (a=list(val=c(1, 2, 3)), b=list(val=c(1, 2, 3, 4)))
    > $a
    > $a$val
    > [1] 1 2 3
    > 
    > 
    > $b
    > $b$val
    > [1] 1 2 3 4
    > ```

​      

- 리스트 데이터 접근

  리스트에 저장된 데이터는 색인 또는 키를 사용해 접근할 수 있다.

  ▼ **표 2-13** 리스트 데이터 접근 문법

  | 문법  | 의미                                   |
  | ----- | -------------------------------------- |
  | x$key | 리스트 x에서 키 값 key에 해당하는 값   |
  | x[n]  | 리스트 x에서 n번째 데이터의 서브리스트 |
  | x     | 리스트 x에서 n번째 저장된 값           |

  앞에서 살펴본 것처럼 리스트를 출력해보면 ‘$키’ 형태로 각 키가 나열된다. 데이터는 ‘x$key’ 형태로 접근한다. 또는 각 요소를 순서대로 x 형태로 접근할 수도 있다.

  ```bash
  > x <- list(name="foo", height=c(1, 3, 5))
  > x$name
  [1] "foo"
  > x$height
  [1] 1 3 5
  > x1
  [1] "foo"
  > x2
  [1] 1 3 5
  ```

  x과 달리 x[n] 형태는 각 값이 아니라 ‘(키, 값)’을 담고 있는 서브리스트를 반환한다. 예를 들어, 다음 코드를 보자.

  ```bash
  > x[1]
  $ name
  [1] "foo"
  > x[2]
  $ height
  [1] 1 3 5
  ```

  코드에서 볼 수 있듯이 x[1]은 (name, “foo”)를 담고 있는 리스트다.

##### 행렬

- 한 가지 타입이 들어간다. 

##### :star: 데이터 프레임

- 처리할 데이터 마치 엑셀의 스프레드시트와 같이 표 형태로 정리한 모습을 하고 있다. 
- 다양한 타입이 들어 간다.
-  R에서 가장 중요한 데이터 타입이며, 많은 R 함수에서 인자로 데이터 프레임을 받는다.
- 생성 )
  -  data.frame : 데이터 프레임을 생성한다.

## 데이터 조작 : 벡터 기반 처리와 외부 데이터 처리

- R에서는 주로 벡터(한가지 타입만 들어가는 1차원 배열) 기반으로 데이터를 처리한다. 벡터 기반 처리는 개별 요소를 for 루프 등으로 하나씩 처리하는 방식보다 빠르게 수행될 뿐만 아니라 손쉽게 병렬화가 가능하다. 이 장에서는 이러한 벡터 기반 처리를 돕는 R의 기본 함수들을 설명할 것이다. 이러한 함수는 데이터 처리를 위한 핵심적인 함수다. 앞으로 보게 될 대부분의 R 코드에서 이 함수들을 사용하고 있을 것이다. 따라서 이 함수들의 사용법을 잘 아는 것이 R 코드를 작성하고 이해하는 데 중요한 역할을 한다.

> 지금까지 배운것 ) R Varivble 1.scalar 2.factor 3.vector 4.matrix 5.data frame R function R programming

1. 아이리스 데이터

   - 아이리스는 통계학자인 피셔Fisher[**1**](https://thebook.io/006723/ch04/01/#footnote-101232-1) 가 소개한 데이터로, 붓꽃의 3가지 종(setosa, versicolor, virginica)에 대해 꽃받침sepal과 꽃잎petal의 길이를 정리한 데이터다. 이 데이터는 R에 기본으로 내장되어 있고, 이해하기 쉬우며 크기가 작고 기계 학습에서 인기 있는 분야 중 하나인 분류Classification에 적합한 데이터다. 

     | 컬럼명       | 의미                                                        | 데이터 타입 |
     | ------------ | ----------------------------------------------------------- | ----------- |
     | Species      | 붓꽃의 종. setosa, versicolor, virginica 세 가지 값 중 하나 | Factor      |
     | Sepal.Width  | 꽃받침의 너비                                               | Number      |
     | Sepal.Length | 꽃받침의 길이                                               | Number      |
     | Petal.Width  | 꽃잎의 너비                                                 | Number      |
     | Petal.Length | 꽃잎의 길이                                                 | Number      |

>  사용예시 )
>
> iris에는 붓꽃의 종별로 50행씩, 총 150개 행이 저장되어 있다.
>
> ```bash
> > head(iris)
>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
> 1         5.1         3.5         1.4         0.2   setosa
> 2         4.9         3.0         1.4         0.2   setosa
> 3         4.7         3.2         1.3         0.2   setosa
> 4         4.6         3.1         1.5         0.2   setosa
> 5         5.0         3.6         1.4         0.2   setosa
> 6         5.4         3.9         1.7         0.4   setosa
> > str(iris) #데이터의 생김새를 보고 싶을 때 (str)
> 'data.frame':    150 obs. of 5 variables:
>  $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
>  $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
>  $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
>  $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
>  $ Species : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> ```
>
> iris에는 붓꽃 데이터가 데이터 프레임으로 저장되어 있는 반면, iris3에는 3차원 배열 형태로 저장되어 있다.
>
> ```bash
> > iris3
> , , Setosa
> 
>      Sepal L.  Sepal W.  Petal L.  Petal W.
> [1,]     5.1       3.5       1.4       0.2
> [2,]     4.9       3.0       1.4       0.2
> ...
> 
> , , Versicolor
> 
>      Sepal L.  Sepal W.  Petal L.  Petal W.
> [1,]     7.0       3.2       4.7       1.4
> [2,]     6.4       3.2       4.5       1.5
> ...
> 
> , , Virginica
> 
>      Sepal L.  Sepal W.  Petal L.  Petal W.
> [1,]     6.3       3.3       6.0       2.5
> [2,]     5.8       2.7       5.1       1.9
> ...
> 
> ```
>
> 참고) 피셔는 통계학자, 유전학자, 진화생물학자로서 현대 통계학에 지대한 공을 세운 학자다. 통계학자 중 한 사람인 앤더스 할드(Anders Hald)는 그를 일컬어 ‘현대 통계학의 토대를 거의 혼자서 만들어낸 천재’로 지칭했다. 관심 있는 독자는 피셔에 대한 위키피디아 문서인 http://en.wikipedia.org/wiki/Ronald_Fisher를 참고하기 바란다.

- 자주 사용하는 데이터 셋

  | 데이터 셋    | 의미                                                         |
  | ------------ | ------------------------------------------------------------ |
  | AirPassenger | 1949년부터 1960년까지의 항공기 승객 수                       |
  | airquality   | 1973년 5월부터 9월까지의 뉴욕 대기 오염 정도에 대한 기록     |
  | cars         | 자동차의 주행 속도에 따른 제동 거리                          |
  | mtcars       | 1974년 미국 모터 트렌드 매거진에 실린 32개 자동차에 대해 연료 효율을 비롯한 10여 가지 특징을 기록 |
  | Titanic      | 타이타닉 호의 생존자 정보를 호실(1등실, 2등실, 3등실), 성별, 나이, 생존 여부로 정리 |
  | InsectSprays | 6종류의 살충제를 사용했을 때 각 살충제에 대해 살아남은 벌레의 수 |
  | Orange       | 오렌지 나무의 종류, 연령, 둘레                               |
  | swiss        | 1888년경 프랑스어를 사용하는 스위스 내 47개 주의 출산율과 사회 경제적 지표(농업 종사자 비율, 군 입대 시험 성적, 교육 등) |

- 이들 데이터를 사용할 때는 ‘data(데이터 셋 이름)’ 명령을 사용한다. 예를 들어, mtcars를 살펴보려면 다음과 같은 명령을 사용한다.

  ```bash
  > data(mtcars)
  > head(mtcars)
                     mpg cyl disp  hp drat    wt  qsec vs am gear carb
  Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
  Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
  Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
  Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
  Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
  Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
  ```

  

- 파일 입출력

  - CSV로 저장된 외부 데이터 파일을 데이터 프레임으로 불러들이는 방법

    - read.csv : CSV 파일을 데이터 프레임으로 읽어들인다.

      ```bash
      read.csv(
        file,          # 파일명
        header=FALSE,  # 파일의 첫 행을 헤더로 처리할 것인지 여부
        # 데이터에 결측치가 포함되어 있을 경우 R의 NA에 대응시킬 값을 지정한다.
        # 기본값은 "NA"로, "NA"로 저장된 문자열들은 R의 NA로 저장된다.
        na.strings="NA",
        # 문자열을 팩터로 저장할지 또는 문자열로 저장할지 여부를 지정하는 데 사용한다. 별다른
        # 설정을 하지 않았다면 기본값은 보통 TRUE다.
        stringsAsFactors=default.stringsAsFactors()
      )
      #반환 값은 데이터 프레임이다.
      ```

      ```bash
      user <- read.csv("user.csv",header=FALSE,stringsAsFactors=FALSE,na.string="NA",encoding="EUC-KR")
      #stringsAsFactors=default.stringsAsFactors() 하면 문자를 factor로 인식, FALSE면 chractor로 인식
      #encoding 은 언어 속성 지정
      #header= TRUE 는 header를 기입하면 가져온다. 만약 없으면 FALSE로 header 없이 나오게 한다.
      colnames(user) <- c("ID","NAME","AGE","WEIGHT","HEIGHT")
      #파일에 header 가 없을 경우 colnames를 사용하여 header를 생성해 준다.
      user
      str(user)
      
      (Console)
      > user <- read.csv("user.csv",header=FALSE,stringsAsFactors=FALSE)
      > #stringsAsFactors=default.stringsAsFactors() 하면 문자를 factor로 인식, FALSE면 chractor로 인식
      > 
      > #header= TRUE 는 header를 기입하면 가져온다. 만약 없으면 FALSE로 header 없이 나오게 한다.
      > colnames(user) <- c("ID","NAME","AGE","WEIGHT","HEIGHT",na.string="NA")
      Error in names(x) <- value : 
        'names' attribute [6] must be the same length as the vector [5]
      > #파일에 header 가 없을 경우 colnames를 사용하여 header를 생성해 준다.
      > user
         V1     V2 V3 V4   V5
      1 100 이승엽 26 75  175
      2 101 정승엽 28 80  180
      3 102 홍승엽 29 78 NULL
      4 103 김승엽 30 NA  188
      5 104 한승엽 31 90  179
      6 105 강승엽 32 77  176
      > user <- read.csv("user.csv",header=FALSE,stringsAsFactors=FALSE)
      > #stringsAsFactors=default.stringsAsFactors() 하면 문자를 factor로 인식, FALSE면 chractor로 인식
      > 
      > #header= TRUE 는 header를 기입하면 가져온다. 만약 없으면 FALSE로 header 없이 나오게 한다.
      > colnames(user) <- c("ID","NAME","AGE","WEIGHT","HEIGHT",na.string="NA",encoding="EUC-KR")
      Error in names(x) <- value : 
        'names' attribute [7] must be the same length as the vector [5]
      > #파일에 header 가 없을 경우 colnames를 사용하여 header를 생성해 준다.
      > user
         V1     V2 V3 V4   V5
      1 100 이승엽 26 75  175
      2 101 정승엽 28 80  180
      3 102 홍승엽 29 78 NULL
      4 103 김승엽 30 NA  188
      5 104 한승엽 31 90  179
      6 105 강승엽 32 77  176
      > user <- read.csv("user.csv",header=FALSE,stringsAsFactors=FALSE,na.string="NA",encoding="EUC-KR")
      > #stringsAsFactors=default.stringsAsFactors() 하면 문자를 factor로 인식, FALSE면 chractor로 인식
       # user$NAME <-as.character(user$NAME) 사용하여 특정 칼럼을 character로 변경해도 된다.
      > 
      > #header= TRUE 는 header를 기입하면 가져온다. 만약 없으면 FALSE로 header 없이 나오게 한다.
      > colnames(user) <- c("ID","NAME","AGE","WEIGHT","HEIGHT")
      > #파일에 header 가 없을 경우 colnames를 사용하여 header를 생성해 준다.
      > user
         ID   NAME AGE WEIGHT HEIGHT
      1 100 이승엽  26     75    175
      2 101 정승엽  28     80    180
      3 102 홍승엽  29     78   NULL
      4 103 김승엽  30     NA    188
      5 104 한승엽  31     90    179
      6 105 강승엽  32     77    176
      ```

      > (user.csv 파일 형태 ) -header 존재 X
      >
      > 100,이승엽,26,75,175
      > 101,정승엽,28,80,180
      > 102,홍승엽,29,78,NULL
      > 103,김승엽,30,,188
      > 104,한승엽,31,90,179
      > 105,강승엽,32,77,176
      >
      > 

    - write.csv : 데이터 프레임을 CSV로 저장한다.

      ```bash
      write.csv(
        x,              # 파일에 저장할 데이터 프레임 또는 행렬
        file="",        # 데이터를 저장할 파일명
        row.names=TRUE  # TRUE면 행 이름을 CSV 파일에 포함하여 저장한다.
      )
      ```

      ```bash
      write.csv(
        user,
        file = "user2.csv",
        row.names = TRUE
      )
      
      (console)
      > write.csv(
      +   user,
      +   file = "user2.csv",
      +   row.names = TRUE
      + )
      
       user2.csv 파일을 확인해보면
      "","ID","NAME","AGE","WEIGHT","HEIGHT"
      "1",100,"이승엽",26,75,"175"
      "2",101,"정승엽",28,80,"180"
      "3",102,"홍승엽",29,78,"NULL"
      "4",103,"김승엽",30,NA,"188"
      "5",104,"한승엽",31,90,"179"
      "6",105,"강승엽",32,77,"176"
      ```

      

- 문제 )

  ```bash
  #함수명 : useravg
  #user.csv 파일을 읽어서 나이, 몸무게, 키의 평균을 구하고
  #3가지 평균 정보를 가진 vector를 파일로 저장하시오
  #파일명은 useravg.cvs 
  #예) age, weight, height 
  #    27.4 , 80.2 , 178.3
  savefile <- function(d){
    write.csv(
      d,
      file = "useravg.cvs",
      row.names = FALSE,
      names = TRUE
      
    )  
  }
  useravg <- function(){
    user <- read.csv("user.csv",header=FALSE,stringsAsFactors=FALSE,na.string=NULL,encoding="EUC-KR")
    colnames(user) <- c("ID","NAME","AGE","WEIGHT","HEIGHT")
    user2 <- c(mean(user$AGE, na.rm = TRUE),mean(user$WEIGHT, na.rm = TRUE),mean(user$HEIGHT,na.rm = TRUE))
    
    names(user2) <- c("AGE","WEIGHT","HEIGHT")
    savefile(user2)
    return(user2)   
  }
  
  useravg()
  ```

  

## 객체의 파일 입출력

- 데이터를 다양한 알고리즘으로 장시간 처리한 뒤 파일에 저장해두면 나중에 같은 계산을 반복할 필요가 없어 효율적이다. 바이너리 파일로 R 객체를 저장하고 불러들이는 함수에는 save( ), load( )가 있다.

  - save : 메모리에 있는 객체를 파일에 저장한다.

    ```bash
    save(
      ...,               # 저장할 객체의 이름
      list=character(),  # 저장할 객체의 이름을 벡터로 지정할 경우 ... 대신 사용
      file               # 파일명
    )
    ```

    

  - load : 파일로부터 객체를 메모리로 읽어들인다.

    ```bash
    load(
      file  # 파일명
    )
    #반환 값은 파일에서 읽어들인 객체의 이름들을 저장한 벡터다.
    ```

    - 다음은 두 벡터 x, y를 xy.RData 파일에 저장하는 예다.

      ```bash
      > x <- 1:5
      > y <- 6:10
      > save(x, y, file="xy.RData")
      ```

      메모리에 있는 모든 객체를 저장하고자 한다면 메모리에 있는 객체 목록을 조회하는 함수 ls( )[**2**](https://thebook.io/006723/ch04/02/02/#footnote-101232-2) 의 결과를 list 인자에 지정할 수 있다. 다음은 a, b, c 객체를 파일 abc.RData에 저장하는 예다.

      ```bash
      > rm(list=ls())  # 메모리에 있는 객체를 모두 삭제
      > a <- 1:5
      > b <- 6:10
      > c <- 11:15
      > save(list=ls(), file="abc.RData")
      ```

      파일로부터 데이터를 불러들이는 함수는 load( )다. 다음 코드는 abc.RData 파일로부터 a, b, c 객체를 불러들이는 예를 보여준다.

      ```bash
      > rm(list=ls())
      > ls()
      character(0)
      > load("abc.RData")
      > ls()
      [1] "a" "b" "c"
      > a
      [1] 1 2 3 4 5
      > b
      [1] 6 7 8 9 10
      > c
      [1] 11 12 13 14 15
      ```

      ```bash
      v1 <- c(1:10)
      save(v1,file="v1.dat")
      rm(list=ls())
      load("v1.dat")
      
      Environment에 rm 으로 모든 list가 지워지고 저장되었던 vi.dat리 load 되는 것을 확인 할 수 있다.
      ```

      

## 데이터 프레임의 행과 컬럼 합치기

rbind( )와 cbind( )는 각각 행 또는 컬럼 형태로 주어진 벡터, 행렬, 데이터 프레임을 합쳐서 결과로 행렬 또는 데이터 프레임을 만드는 데 사용한다. 이들 함수는 분리되어 저장된 데이터를 합치는 데 유용하게 사용할 수 있다.

예를 들어, c(1, 2, 3), c(4, 5, 6)이라는 두 벡터는 rbind( )를 사용해 각 벡터를 한 행으로 하는 행렬로 합칠 수 있다.

```bash
> rbind(c(1, 2, 3), c(4, 5, 6))
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
```

마찬가지로 데이터 프레임 역시 rbind( )를 사용하여 행을 합칠 수 있다. 다음은 2개 행을 저장한 데이터 프레임 x와 새로운 값을 저장한 벡터 c(3, “c”)를 rbind( )로 합쳐서 새로운 데이터 프레임 y에 저장하는 예다.

```bash
> (x <- data.frame(id=c(1, 2), name=c("a", "b"), stringsAsFactors=F))
  id  name
1  1     a
2  2     b
> str(x)
'data.frame':    2 obs. of 2 variables:
 $ id  : num  1 2
 $ name: chr "a" "b"
> (y <- rbind(x, c(3, "c")))
  id  name
1  1     a
2  2     b
3  3     c
```

위 코드의 첫 행에서 stringsAsFactors는 name 컬럼의 데이터를 팩터가 아니라 문자열로 취급하기 위해 필요하다. 만약 stringsAsFactors를 지정하지 않으면 “a”, “b”가 팩터 데이터로 취급되어 이름을 표현하려는 컬럼의 목적에 어긋나게 된다.

| 함수       | 의미                                      |
| ---------- | ----------------------------------------- |
| rbind(...) | 지정한 데이터들을 행으로 취급해 합친다.   |
| cbind(...) | 지정한 데이터들을 컬럼으로 취급해 합친다. |

```bash
x <- data.frame(id=c(1, 2), name=c("a", "b"), stringsAsFactors=F)

x$age <- c(20,30)
x
y <-rbind(x,c(1,"c",40))
y <-cbind(y,level=c(1,2,3))
#컬럼명 = 해당 값들 
y

(console)

> x <- data.frame(id=c(1, 2), name=c("a", "b"), stringsAsFactors=F)
> 
> x$age <- c(20,30)
> x
  id name age
1  1    a  20
2  2    b  30
> y <-rbind(x,c(1,"c",40))
> y <-cbind(y,level=c(1,2,3))
> y
  id name age level
1  1    a  20     1
2  2    b  30     2
3  1    c  40     3
```



- 문제 )

  ```bash
  #ID NAME 과 각 과목수를 출력하고 cbind를 써서 평균과 합계를 출력
  
  student <- read.csv("student.csv",header=TRUE,stringsAsFactors = FALSE,na.string="NA",encoding="EUC-KR")
  student2 <- c(mean(as.numeric((student[1,c(3:6)]))),mean(as.numeric(student[2,c(3:6)])),mean(as.numeric(student[3,c(3:6)])),mean(as.numeric(student[4,c(3:6)])),mean(as.numeric(student[5,c(3:6)])),mean(as.numeric(student[6,c(3:6)])),mean(as.numeric(student[7,c(3:6)])),mean(as.numeric(student[8,c(3:6)])))
  student3 <- c(sum(as.numeric((student[1,c(3:6)]))),sum(as.numeric(student[2,c(3:6)])),sum(as.numeric(student[3,c(3:6)])),sum(as.numeric(student[4,c(3:6)])),sum(as.numeric(student[5,c(3:6)])),sum(as.numeric(student[6,c(3:6)])),sum(as.numeric(student[7,c(3:6)])),sum(as.numeric(student[8,c(3:6)])))
  student4 <- cbind(student,avg = student2,sum = student3)
  print(student2)
  student4
  #as.numeric : 타입이 data_frame 이여서 vector로 변환 (타입 확인은 class로 확인) 
  
  (console)
  > student <- read.csv("student.csv",header=TRUE,stringsAsFactors = FALSE,na.string="NA",encoding="EUC-KR")
  > student2 <- c(mean(as.numeric((student[1,c(3:6)]))),mean(as.numeric(student[2,c(3:6)])),mean(as.numeric(student[3,c(3:6)])),mean(as.numeric(student[4,c(3:6)])),mean(as.numeric(student[5,c(3:6)])),mean(as.numeric(student[6,c(3:6)])),mean(as.numeric(student[7,c(3:6)])),mean(as.numeric(student[8,c(3:6)])))
  > student3 <- c(sum(as.numeric((student[1,c(3:6)]))),sum(as.numeric(student[2,c(3:6)])),sum(as.numeric(student[3,c(3:6)])),sum(as.numeric(student[4,c(3:6)])),sum(as.numeric(student[5,c(3:6)])),sum(as.numeric(student[6,c(3:6)])),sum(as.numeric(student[7,c(3:6)])),sum(as.numeric(student[8,c(3:6)])))
  > student4 <- cbind(student,avg = student2,sum = student3)
  > print(student2)
  [1] 90.00 90.75 89.25 91.75 85.50 84.25 89.00 92.50
  > student4
     ID   NAME KO EN MA  SI   avg sum
  1 100 일말숙 90 80 90 100 90.00 360
  2 101 이말숙 91 81 91 100 90.75 363
  3 102 삼말숙 92 82 92  91 89.25 357
  4 103 사말숙 93 83 93  98 91.75 367
  5 104 오말숙 94 84 94  70 85.50 342
  6 105 육말숙 95 85 95  62 84.25 337
  7 106 칠말숙 96 86 96  78 89.00 356
  8 107 팔말숙 97 87 97  89 92.50 370
  ```

> :car:참고)
>
>  newst <-student4[,c(2,7)]
> newst
> #NAME 과 avg만 가져온다.
>
> (console)
>
>   NAME   avg
> 1 일말숙 90.00
> 2 이말숙 90.75
> 3 삼말숙 89.25
> 4 사말숙 91.75
> 5 오말숙 85.50
> 6 육말숙 84.25
> 7 칠말숙 89.00
> 8 팔말숙 92.50
>
> 
>
> _________________________________________
>
> student.csv 파일 )
>
> ID,NAME,KO,EN,MA,SI
> 100,일말숙,90,80,90,100
> 101,이말숙,91,81,91,100
> 102,삼말숙,92,82,92,91
> 103,사말숙,93,83,93,98
> 104,오말숙,94,84,94,70
> 105,육말숙,95,85,95,62
> 106,칠말숙,96,86,96,78
> 107,팔말숙,97,87,97,89        



## apply 계열 함수

R에는 벡터, 행렬 또는 데이터 프레임에 임의의 함수를 적용한 결과를 얻기 위한 apply 계열 함수가 있다. 이 함수들은 데이터 전체에 함수를 한 번에 적용하는 벡터 연산을 수행하므로 속도가 빠르다. 다음은 apply 계열 함수를 요약한 것이다.

| 함수      | 설명                                                         | 다른 함수와 비교했을 때의 특징        |
| --------- | ------------------------------------------------------------ | ------------------------------------- |
| apply( )  | 배열 또는 행렬에 주어진 함수를 적용한 뒤 그 결과를 벡터, 배열 또는 리스트로 반환 | 배열 또는 행렬에 적용                 |
| lapply( ) | 벡터, 리스트 또는 표현식에 함수를 적용하여 그 결과를 리스트로 반환 | 결과가 리스트                         |
| sapply( ) | lapply와 유사하지만 결과를 벡터, 행렬 또는 배열로 반환       | 결과가 벡터, 행렬 또는 배열           |
| tapply( ) | 벡터에 있는 데이터를 특정 기준에 따라 그룹으로 묶은 뒤 각 그룹마다 주어진 함수를 적용하고 그 결과를 반환 | 데이터를 그룹으로 묶은 뒤 함수를 적용 |
| mapply( ) | sapply의 확장된 버전으로, 여러 개의 벡터 또는 리스트를 인자로 받아 함수에 각 데이터의 첫째 요소들을 적용한 결과, 둘째 요소들을 적용한 결과, 셋째 요소들을 적용한 결과 등을 반환 | 여러 데이터를 함수의 인자로 적용      |



- apply( ) : 행렬의 행 또는 열 방향으로 특정 함수를 적용하는 데 사용

  - apply : 배열 또는 행렬에 함수 FUN을 MARGIN 방향으로 적용하여 결과를 벡터, 배열 또는 리스트로 반환한다. 

    ```bash
    apply(
      X,       # 배열 또는 행렬
      MARGIN,  # 함수를 적용하는 방향. 1은 행 방향, 2는 열 방향
               # c(1, 2)는 행과 열 방향 모두를 의미
      FUN      # 적용할 함수
    )
    #반환 값은 FUN이 길이 1인 벡터들을 반환한 경우 벡터, 1보다 큰 벡터들을 반환한 경우 행렬, 서로 다른 길이의 벡터를 반환한 경우 리스트다.
    ```

    apply( )가 적용된 결과가 벡터, 배열, 리스트 중 어떤 형태로 반환될 것인지는 데이터 X의 데이터 타입과 함수 FUN의 반환 값에 따라 대부분 자연스럽게 예상할 수 있으므로, 반환 값의 데이터 타입에 대해 크게 걱정할 필요는 없다. 또, 반환 값을 str( )로 검토하면 데이터 타입을 알아낼 수 있다는 점을 기억하기 바란다.

    합을 구하는 함수 sum( )을 apply( )에 적용하는 예에 대해 알아보자. sum( )은 인자로 주어진 값들의 합을 구하는 간단한 함수다. 예를 들어, 다음은 1부터 10까지의 합을 계산한다.

    ```bash
    > sum(1:10)
    [1] 55
    ```

    이를 사용해 apply( )로 행렬에 저장된 데이터의 합을 구해보자. 예를 들어, 다음과 같은 행렬이 있다고 하자.

    ```bash
    > d <- matrix(1:9, ncol=3)
    > d
         [,1] [,2] [,3]
    [1,]    1    4    7
    [2,]    2    5    8
    [3,]    3    6    9
    ```

    이 행렬의 각 행의 합(즉, 1+4+7, 2+5+8, 3+6+9)을 구하려면 apply를 행별로(즉, MARGIN에 1을 지정) 처리하되 각 행에 대해 sum 함수를 호출하면 된다.

    ```bash
    > apply(d, 1, sum)
    [1] 12 15 18
    ```

    마찬가지로 열 방향 합(1+2+3, 4+5+6, 7+8+9)은 MARGIN=2를 지정해 구한다.

    ```bash
    > apply(d, 2, sum)
    [1] 6 15 24
    ```

    ```bash
    student <- read.csv("student.csv",header=TRUE,stringsAsFactors = FALSE,na.string="NA",encoding="EUC-KR")
    
    stss <- apply(student[,c(3:6)],2,mean)
    sts <- apply(student[,c(3:6)],1,mean)
    names(sts) <- student[,2]
    
    sts
    stss
    dfstss <- as.data.frame(stss)
    colnames(dfstss) <- "average" #vector 이름 변경은 names , data_frame 은 colnames
    #as.data.frame : 결과 값vector를 data.frame 형태로 저장
    
    
    colMeans(student[,c(3:6)]) #apply 2와 같다.
    rowMeans(student[,c(3:6)]) #apply 1과 같다.
    
    
    (console)
    > student <- read.csv("student.csv",header=TRUE,stringsAsFactors = FALSE,na.string="NA",encoding="EUC-KR")
    > 
    > stss <- apply(student[,c(3:6)],2,mean)
    > sts <- apply(student[,c(3:6)],1,mean)
    > names(sts) <- student[,2]
    > sts
    일말숙 이말숙 삼말숙 사말숙 오말숙 육말숙 칠말숙 
     90.00  90.75  89.25  91.75  85.50  84.25  89.00 
    팔말숙 
     92.50 
    > stss <- apply(student[,c(3:6)],2,mean)
    > student <- read.csv("student.csv",header=TRUE,stringsAsFactors = FALSE,na.string="NA",encoding="EUC-KR")
    > 
    > stss <- apply(student[,c(3:6)],2,mean)
    > stss
      KO   EN   MA   SI 
    93.5 83.5 93.5 86.0 
    > colMeans(student[,c(3:6)])
      KO   EN   MA   SI 
    93.5 83.5 93.5 86.0 
    > rowMeans(student[,c(3:6)])
    [1] 90.00 90.75 89.25 91.75 85.50 84.25 89.00 92.50
    ```

    

    - | rowSums : 숫자 배열 또는 데이터 프레임에서 행의 합을 구한다. |
      | ------------------------------------------------------------ |
      | `rowSums(   x,            # 배열 또는 숫자를 저장한 데이터 프레임   na.rm=FALSE,  # NA를 제외할지 여부 )`반환 값은 행 방향에 저장된 값의 합이다. |
      | rowMeans : 숫자 배열 또는 데이터 프레임에서 행의 평균을 구한다. |
      | `rowSums(   x,            # 배열 또는 숫자를 저장한 데이터 프레임   na.rm=FALSE,  # NA를 제외할지 여부 )`반환 값은 행 방향에 저장된 값의 평균이다. |

- lapply( ) : 리스트를 반환하는 특징이 있는 apply 계열 함수다.

- sapply(): sapply( )는 lapply( )와 유사하지만 리스트 대신 행렬, 벡터 등의 데이터 타입으로 결과를 반환하는 특징이 있는 함수다. (apply와 비슷)

  ```bash
  sapply : 벡터, 리스트, 표현식, 데이터 프레임 등에 함수를 적용하고 그 결과를 벡터 또는 행렬로 반환한다.
  
  sapply(
    X,    # 벡터, 리스트, 표현식 또는 데이터 프레임
    FUN,  # 적용할 함수
    ...,  # 추가 인자. 이 인자들은 FUN에 전달된다.
  )
  반환 값은 FUN의 결과가 길이 1인 벡터들이면 벡터, 길이가 1보다 큰 벡터들이면 행렬이다.
  ```

  ```
  head(iris)
  irisr <- apply(iris[,c(1:4)], 2, mean)
  irisr2 <- colMeans(iris[,c(1:4)])
  
  siris <- sapply(iris[,c(1:4)],mean)
  class(siris)
  
  (console)
  > irisr <- apply(iris[,c(1:4)], 2, mean)
  > irisr2 <- colMeans(iris[,c(1:4)])
  > 
  > siris <- sapply(iris[,c(1:4)],mean)
  > class(siris)
  [1] "numeric"
  ```

  예를 들어, 아이리스의 컬럼별로 평균을 구하는 경우를 살펴보자. 다음 코드에서 볼 수 있듯이 lapply( )는 결과를 리스트로 반환하지만, sapply( )는 벡터를 반환한다.

  ```bash
  > lapply(iris[, 1:4], mean)
  $Sepal.Length
  [1] 5.843333
  
  $Sepal.Width
  [1] 3.057333
  
  $Petal.Length
  [1] 3.758
  
  $Petal.Width
  [1] 1.199333
  > sapply(iris[, 1:4], mean)
  Sepal.Length  Sepal.Width  Petal.Length  Petal.Width
      5.843333     3.057333      3.758000     1.199333
  > class(sapply(iris[, 1:4], mean))  # "numeric"은 숫자를 저장한 벡터를 의미함
  [1] "numeric"
  ```

  sapply( )에서 반환한 벡터는 as.data.frame( )을 사용해 데이터 프레임으로 변환할 수 있다. 이때 t(x)를 사용해 벡터의 행과 열을 바꿔주지 않으면 기대한 것과 다른 모양의 데이터 프레임을 얻게 된다. 다음은 아이리스의 컬럼별 평균을 sapply( )를 사용해 벡터로 구한 뒤 이를 다시 데이터 프레임으로 변환하는 예다.

  ```bash
  > x <- sapply(iris[, 1:4], mean)
  > as.data.frame(x)
                      x
  Sepal.Length 5.843333
  Sepal.Width  3.057333
  Petal.Length 3.758000
  Petal.Width  1.199333
  > as.data.frame(t(x))
    Sepal.Length  Sepal.Width  Petal.Length  Petal.Width
  1     5.843333     3.057333       3.758       1.199333
  ```

  다수의 컬럼을 포함하는 데이터 프레임을 처리하다 보면 종종 각 컬럼의 데이터 타입을 알아내고 싶을 때가 있다. 예를 들면, 어떤 컬럼에 숫자가 저장되어 있는지를 판단하는 경우다. 이때 sapply( )를 유용하게 사용할 수 있다. 다음은 아이리스 데이터에서 각 컬럼의 데이터 타입을 구하는 예다

  ```bash
  > sapply(iris, class)
  Sepal.Length  Sepal.Width  Petal.Length  Petal.Width   Species
     "numeric"    "numeric"     "numeric"    "numeric"   "factor"
  ```

​       지금까지 설명한 sapply( )의 사용 예에서 FUN은 1개 값을 반환했다. 예를 들어, mean 함수의 반환 값은 1개 값이다. 이 경우 sapply( )의 결과는 이들 값을 모은 벡터가 된다. 하지만 sapply( )에 인자로 주어진 함수의 출력이 길이가 1보다 큰 벡터들이라면 sapply( )는 행렬을 반환한다. 다음 예에서는 아이리스의 숫자형 값들에 대해 각 값이 3보다 큰지 여부를 판단한다. sapply( )에 넘긴 FUN의 반환 값이 길이가 1보다 큰 벡터기 때문에 sapply( )의 수행 결과는 행렬이다.

```
> y <- sapply(iris[, 1:4], function(x) { x > 3 })
> class(y)
[1] "matrix"
> head(y)
     Sepal.Length Sepal.Width Petal.Length Petal.Width
[1,]         TRUE        TRUE        FALSE       FALSE
[2,]         TRUE        FALSE       FALSE       FALSE
[3,]         TRUE        TRUE        FALSE       FALSE
[4,]         TRUE        TRUE        FALSE       FALSE
[5,]         TRUE        TRUE        FALSE       FALSE
[6,]         TRUE        TRUE        FALSE       FALSE
...
```

sapply( )는 한 가지 타입만 저장 가능한 데이터 타입인 벡터 또는 행렬을 반환하므로 sapply( )에 인자로 준 함수 FUN의 반환 값에 여러 가지 데이터 타입이 섞여 있으면 안 된다. 만약 각 컬럼에 대해 수행한 함수의 결과 데이터 타입이 서로 다르다면, 리스트를 반환하는 lapply( )나 리스트 또는 데이터 프레임을 반환할 수 있는 plyr 패키지(5장에서 설명)를 사용해야 한다.

- tapply

  - tapply( )는 그룹별로 함수를 적용하기 위한 apply 계열 함수다.

    ```bash
    
    tapply : 벡터 등에 저장된 데이터를 주어진 기준에 따라 그룹으로 묶은 뒤 각 그룹에 함수를 적용하고 그 결과를 반환한다.
    
    tapply(
      X,      # 벡터
      INDEX,  # 데이터를 그룹으로 묶을 색인. 팩터를 지정해야 하며 팩터가 아닌 타입이 지정되면
              # 팩터로 형 변환된다.
      FUN,    # 각 그룹마다 적용할 함수
      ...,    # 추가 인자. 이 인자들은 FUN에 전달된다.
    )
    ```

    ```bash
    head(iris)
    irisr <- apply(iris[,c(1:4)], 2, mean)
    irisr2 <- colMeans(iris[,c(1:4)])
    
    tapply(iris$Sepal.Length, iris$Species, mean)
    
    (console)
    > tapply(iris$Sepal.Length, iris$Species, mean)
        setosa versicolor  virginica 
         5.006      5.936      6.588 
    ```

    다음과 같은 예를 생각해보자. 1부터 10까지의 숫자가 있고 이들이 모두 한 그룹에 속해 있을 때, 이 그룹에 속한 데이터의 합을 구하면 55가 될 것이다.

    ```bash
    > tapply(1:10, rep(1, 10), sum)
     1
    55
    ```

    위 코드에서 rep(1, 10)은 1을 10회 반복하는 것을 의미한다. 따라서 숫자 1, 2, 3, …, 10에 대해 동일한 소속 번호 1, 1, 1, …, 1을 부여한 것이다. 그러므로 그룹 1에 속한 데이터의 합은 55(=1+2+3+…+10)다.

    이번에는 1부터 10까지의 숫자를 홀수별, 짝수별로 묶어서 합을 구해보자. INDEX에 홀수와 짝수별로 다른 팩터 값이 주어지도록 %% 2[**4**](https://thebook.io/006723/ch04/04/04-1/#footnote-101232-4)를 사용했다.

    ```bash
    > tapply(1:10, 1:10 %% 2 == 1, sum)
    FALSE TRUE
       30   25
    ```

    수행 결과 짝수의 합이 30(=2+4+6+8+10), 홀수의 합이 25(=1+3+5+7+9)로 구해졌다. 아이리스 데이터에서 Species별 Sepal.Length의 평균을 구해보자.

    ```bash
    > tapply(iris$Sepal.Length, iris$Species, mean)
        setosa versicolor virginica
         5.006      5.936     6.588
    ```

    이번에는 조금 더 복잡한 그룹화를 다뤄보자. 계절별 성별로 정리된 판매량 데이터가 다음과 같이 주어졌다고 하자.

    ```bash
    > m <- matrix(1:8,
    +             ncol=2,
    +             dimnames=list(c("spring", "summer", "fall", "winter"),
    +                           c("male", "female")))
    > m
            male female
    spring     1      5
    summer     2      6
    fall       3      7
    winter     4      8
    ```

    행렬의 행은 봄, 여름, 가을, 겨울을 뜻하고 열은 성별을 의미한다. 이때 반기별, 성별 셀의 합을 구해보자. 즉, 상반기(봄, 여름)의 남성 셀 합(=1+2)과 여성 셀 합(=5+6), 하반기(가을, 겨울)의 남성 셀 합(=3+4)과 여성 셀 합(=7+8)을 구하는 것이 목표다.

    이 연산을 수행하기 위한 성별, 분기별 그룹은 다음과 같이 구성할 수 있다. 그림에서 (n, m) 값은 tapply( )에 INDEX로 주어질 값들을 의미한다.

    ▼ **표 4-13** 성별, 분기별 그룹을 위한 INDEX

    |        | male   | female |        |      |
    | ------ | ------ | ------ | ------ | ---- |
    | spring | (1, 1) | 1      | (1, 2) | 5    |
    | summer | (1, 1) | 2      | (1, 2) | 6    |
    | fall   | (2, 1) | 3      | (2, 2) | 7    |
    | winter | (2, 1) | 4      | (2, 2) | 8    |

    INDEX를 실제로 지정할 때는 (n, m)에서 n을 먼저 나열한 뒤 m 값을 나열한다. 즉, 그룹 (n1, m1), (n2, m2)는 list(c(n1, n2), c(m1, m2))로 표현한다. 다음은 이러한 방식으로 tapply( )를 사용한 분기별, 성별 합을 구한 예다.

    ```bash
    > tapply(m, list(c(1, 1, 2, 2, 1, 1, 2, 2),
    +                   c(1, 1, 1, 1, 2, 2, 2, 2)), sum)
      1 2
    1 3 11
    2 7 15
    ```

    tapply( )는 클러스터링 알고리즘을 수행한 후 같은 클러스터에 속한 데이터들의 x 좌표의 평균, y 좌표의 평균을 계산하는 데 사용할 수 있는데, 바로 이때 위와 같은 방식으로 색인을 부여한다. 따라서 조금 복잡해 보여도 여기서 배운 내용을 꼭 알고 넘어가도록 하자.

## 데이터 정렬

데이터를 정렬하는 함수인 sort( )와 order( )를 설명한다. sort( )는 주어진 데이터를 직접 정렬해주는 함수며, order( )는 데이터를 정렬했을 때의 순서를 반환한다.

- sort() : 주어진 벡터를 정렬한 결과를 반환한다.

  ```bash
  sort(
    x,                 # 정렬할 벡터
    decreasing=FALSE,  # 내림차순 여부
    # na.last는 NA 값을 정렬한 결과의 어디에 둘 것인지를 제어한다. na.last=TRUE는 NA 값을
    # 정렬한 결과의 마지막에 두고, na.last=FALSE는 정렬한 값의 처음에 둔다.
    # 기본값인 na.last=NA는 NA 값을 정렬 결과에서 제외한다.
    na.last=NA
  )
  ```

  ```bash
  student <- read.csv("student.csv",header=TRUE,stringsAsFactors = FALSE,na.string="NA",encoding="EUC-KR")
  
  stss <- apply(student[,c(3:6)],2,mean)
  sts <- apply(student[,c(3:6)],1,mean)
  names(sts) <- student[,2]
  
  sts
  stss
  class(stss)
  class(sts)
  dfstss <- as.data.frame(stss)
  colnames(dfstss) <- "average" #vector 이름 변경은 names , data_frame 은 colnames
  df2 <-sort(dfstss$average) #오름차순 정렬
  #sort(dfstss$average , decreasing = TRUE) # 내림차순 정렬
  
  (console)
  > df2
  [1] 83.5 86.0 93.5 93.5
  ```

  

- order() :  주어진 인자를 정렬하기 위한 각 요소의 색인을 반환한다. 

     ```bash
     iris[order(iris$Sepal.Length),]
     ```

#order 요소에 대한 순위를 메긴다. 맨앞에 붙는다.

(console)
> iris[order(iris$Sepal.Length),]
    Sepal.Length Sepal.Width Petal.Length
14           4.3         3.0          1.1
9            4.4         2.9          1.4
39           4.4         3.0          1.3
43           4.4         3.2          1.3
42           4.5         2.3          1.3
4            4.6         3.1          1.5
7            4.6         3.4          1.4
23           4.6         3.6          1.0
48           4.6         3.2          1.4
3            4.7         3.2          1.3
30           4.7         3.2          1.6
12           4.8         3.4          1.6
13           4.8         3.0          1.4
25           4.8         3.4          1.9
31           4.8         3.1          1.6
46           4.8         3.0          1.4
2            4.9         3.0          1.4
10           4.9         3.1          1.5
35           4.9         3.1          1.5
38           4.9         3.6          1.4
58           4.9         2.4          3.3
107          4.9         2.5          4.5
5            5.0         3.6          1.4
8            5.0         3.4          1.5
26           5.0         3.0          1.6
27           5.0         3.4          1.6
36           5.0         3.2          1.2
41           5.0         3.5          1.3
44           5.0         3.5          1.6
50           5.0         3.3          1.4
61           5.0         2.0          3.5
94           5.0         2.3          3.3
1            5.1         3.5          1.4
18           5.1         3.5          1.4
20           5.1         3.8          1.5
22           5.1         3.7          1.5
24           5.1         3.3          1.7
40           5.1         3.4          1.5
45           5.1         3.8          1.9
47           5.1         3.8          1.6
99           5.1         2.5          3.0
28           5.2         3.5          1.5
29           5.2         3.4          1.4
33           5.2         4.1          1.5
60           5.2         2.7          3.9
49           5.3         3.7          1.5
6            5.4         3.9          1.7
11           5.4         3.7          1.5
17           5.4         3.9          1.3
21           5.4         3.4          1.7
32           5.4         3.4          1.5
85           5.4         3.0          4.5
34           5.5         4.2          1.4
37           5.5         3.5          1.3
54           5.5         2.3          4.0
81           5.5         2.4          3.8
82           5.5         2.4          3.7
90           5.5         2.5          4.0
91           5.5         2.6          4.4
65           5.6         2.9          3.6
67           5.6         3.0          4.5
70           5.6         2.5          3.9
89           5.6         3.0          4.1
95           5.6         2.7          4.2
122          5.6         2.8          4.9
16           5.7         4.4          1.5
19           5.7         3.8          1.7
56           5.7         2.8          4.5
80           5.7         2.6          3.5
96           5.7         3.0          4.2
97           5.7         2.9          4.2
100          5.7         2.8          4.1
114          5.7         2.5          5.0
15           5.8         4.0          1.2
68           5.8         2.7          4.1
83           5.8         2.7          3.9
93           5.8         2.6          4.0
102          5.8         2.7          5.1
115          5.8         2.8          5.1
143          5.8         2.7          5.1
62           5.9         3.0          4.2
71           5.9         3.2          4.8
150          5.9         3.0          5.1
63           6.0         2.2          4.0
79           6.0         2.9          4.5
84           6.0         2.7          5.1
86           6.0         3.4          4.5
120          6.0         2.2          5.0
139          6.0         3.0          4.8
64           6.1         2.9          4.7
72           6.1         2.8          4.0
74           6.1         2.8          4.7
92           6.1         3.0          4.6
128          6.1         3.0          4.9
135          6.1         2.6          5.6
69           6.2         2.2          4.5
98           6.2         2.9          4.3
127          6.2         2.8          4.8
149          6.2         3.4          5.4
57           6.3         3.3          4.7
73           6.3         2.5          4.9
88           6.3         2.3          4.4
101          6.3         3.3          6.0
104          6.3         2.9          5.6
124          6.3         2.7          4.9
134          6.3         2.8          5.1
137          6.3         3.4          5.6
147          6.3         2.5          5.0
52           6.4         3.2          4.5
75           6.4         2.9          4.3
112          6.4         2.7          5.3
116          6.4         3.2          5.3
129          6.4         2.8          5.6
133          6.4         2.8          5.6
138          6.4         3.1          5.5
55           6.5         2.8          4.6
105          6.5         3.0          5.8
111          6.5         3.2          5.1
117          6.5         3.0          5.5
148          6.5         3.0          5.2
59           6.6         2.9          4.6
76           6.6         3.0          4.4
66           6.7         3.1          4.4
78           6.7         3.0          5.0
87           6.7         3.1          4.7
109          6.7         2.5          5.8
125          6.7         3.3          5.7
141          6.7         3.1          5.6
145          6.7         3.3          5.7
146          6.7         3.0          5.2
77           6.8         2.8          4.8
113          6.8         3.0          5.5
144          6.8         3.2          5.9
53           6.9         3.1          4.9
121          6.9         3.2          5.7
140          6.9         3.1          5.4
142          6.9         3.1          5.1
51           7.0         3.2          4.7
103          7.1         3.0          5.9
110          7.2         3.6          6.1
126          7.2         3.2          6.0
130          7.2         3.0          5.8
108          7.3         2.9          6.3
131          7.4         2.8          6.1
106          7.6         3.0          6.6
118          7.7         3.8          6.7
119          7.7         2.6          6.9
123          7.7         2.8          6.7
136          7.7         3.0          6.1
132          7.9         3.8          6.4
    Petal.Width    Species
14          0.1     setosa
9           0.2     setosa
39          0.2     setosa
43          0.2     setosa
42          0.3     setosa
4           0.2     setosa
7           0.3     setosa
23          0.2     setosa
48          0.2     setosa
3           0.2     setosa
30          0.2     setosa
12          0.2     setosa
13          0.1     setosa
25          0.2     setosa
31          0.2     setosa
46          0.3     setosa
2           0.2     setosa
10          0.1     setosa
35          0.2     setosa
38          0.1     setosa
58          1.0 versicolor
107         1.7  virginica
5           0.2     setosa
8           0.2     setosa
26          0.2     setosa
27          0.4     setosa
36          0.2     setosa
41          0.3     setosa
44          0.6     setosa
50          0.2     setosa
61          1.0 versicolor
94          1.0 versicolor
1           0.2     setosa
18          0.3     setosa
20          0.3     setosa
22          0.4     setosa
24          0.5     setosa
40          0.2     setosa
45          0.4     setosa
47          0.2     setosa
99          1.1 versicolor
28          0.2     setosa
29          0.2     setosa
33          0.1     setosa
60          1.4 versicolor
49          0.2     setosa
6           0.4     setosa
11          0.2     setosa
17          0.4     setosa
21          0.2     setosa
32          0.4     setosa
85          1.5 versicolor
34          0.2     setosa
37          0.2     setosa
54          1.3 versicolor
81          1.1 versicolor
82          1.0 versicolor
90          1.3 versicolor
91          1.2 versicolor
65          1.3 versicolor
67          1.5 versicolor
70          1.1 versicolor
89          1.3 versicolor
95          1.3 versicolor
122         2.0  virginica
16          0.4     setosa
19          0.3     setosa
56          1.3 versicolor
80          1.0 versicolor
96          1.2 versicolor
97          1.3 versicolor
100         1.3 versicolor
114         2.0  virginica
15          0.2     setosa
68          1.0 versicolor
83          1.2 versicolor
93          1.2 versicolor
102         1.9  virginica
115         2.4  virginica
143         1.9  virginica
62          1.5 versicolor
71          1.8 versicolor
150         1.8  virginica
63          1.0 versicolor
79          1.5 versicolor
84          1.6 versicolor
86          1.6 versicolor
120         1.5  virginica
139         1.8  virginica
64          1.4 versicolor
72          1.3 versicolor
74          1.2 versicolor
92          1.4 versicolor
128         1.8  virginica
135         1.4  virginica
69          1.5 versicolor
98          1.3 versicolor
127         1.8  virginica
149         2.3  virginica
57          1.6 versicolor
73          1.5 versicolor
88          1.3 versicolor
101         2.5  virginica
104         1.8  virginica
124         1.8  virginica
134         1.5  virginica
137         2.4  virginica
147         1.9  virginica
52          1.5 versicolor
75          1.3 versicolor
112         1.9  virginica
116         2.3  virginica
129         2.1  virginica
133         2.2  virginica
138         1.8  virginica
55          1.5 versicolor
105         2.2  virginica
111         2.0  virginica
117         1.8  virginica
148         2.0  virginica
59          1.3 versicolor
76          1.4 versicolor
66          1.4 versicolor
78          1.7 versicolor
87          1.5 versicolor
109         1.8  virginica
125         2.1  virginica
141         2.4  virginica
145         2.5  virginica
146         2.3  virginica
77          1.4 versicolor
113         2.1  virginica
144         2.3  virginica
53          1.5 versicolor
121         2.3  virginica
140         2.1  virginica
142         2.3  virginica
51          1.4 versicolor
103         2.1  virginica
110         2.5  virginica
126         1.8  virginica
130         1.6  virginica
108         1.8  virginica
131         1.9  virginica
106         2.1  virginica
118         2.2  virginica
119         2.3  virginica
123         2.0  virginica
136         2.3  virginica
132         2.0  virginica
     ```

## 그룹별 연산

- doBy가 데이터를 그룹별로 나눈 후 특정 계산을 적용하기 위한 함수들의 패키지인 반면 aggregate( )는 좀 더 일반적인 그룹별 연산을 위한 함수다. aggregate( )를 사용하면 데이터를 그룹으로 묶은 후 임의의 함수를 그룹에 적용할 수 있다.

- aggregate : tapply와 같지만 data_frame 형태로 반환, 데이터를 분할하고 각 그룹마다 요약치를 계산한다.

  ```bash
  aggregate(
    x, # R 객체
    by, # 그룹으로 묶을 값의 리스트
    FUN # 그룹별로 요약치 계산에 사용할 함수
  )
  
  aggregate(
    formula, # y ~ x 형태로 y는 계산에 사용될 값이며, x는 그룹으로 묶을 때 사용할 기준값
    data, # formula를 적용할 데이터
    FUN
  )
  입력이 데이터 프레임인 경우, 반환 값은 그룹 값과 그룹의 요약치를 저장한 데이터 프레임이다.
  ```

  

       ```bash

  iris[order(iris$Sepal.Length),]

#order 요소에 대한 순위를 메긴다.

ta <- tapply(iris$Sepal.Length,iris$Species, mean)
class(ta)
tag <- aggregate(Sepal.Length ~ Species, iris,mean)
class(tag)

(console)
> ta <- tapply(iris$Sepal.Length,iris$Species, mean)
> class(ta)
[1] "array"
> tag <- aggregate(Sepal.Length ~ Species, iris,mean)
> class(tag)
[1] "data.frame"
       ```

이 절에서는 aggregate( )에 포뮬러를 적용한 형태의 예를 살펴본다. 다음은 아이리스 데이터에서 종별 Sepal.Width의 평균 길이를 구하는 예다.

```
> aggregate(Sepal.Width ~ Species, iris, mean)
     Species Sepal.Width
1     setosa       3.428
2 versicolor       2.770
3  virginica       2.974
```

같은 일을 tapply( )를 통해서 수행하면 다음과 같다.

```
> tapply(iris$Sepal.Length, iris$Species, mean)
   setosa versicolor virginica
    5.006      5.936     6.588
```

얻는 결과는 같지만 포뮬러를 사용한 aggregate( ) 쪽이 코드 작성하기 편리하다.

## 외부라이브러리 이용한 함수

- console에 필요한 라이브러리를 설치

  ```bash
  >install.packages("sqldf")
  ```

  > sqldf : hive(mapreduce) 처럼 sql 롤 값을 가져올 수 있다. (ANSI 기준)

- library를 사용하여 script에 가져오기

```bash
library(sqldf)
```

- (sqldf) species 그룹으로 Sepal.Length 와 Sepal.Width의 평균을 출력.

```bash
library(sqldf)
head(iris)
result <- sqldf('select avg("Sepal.Length") as "Sepal.Length",avg("Sepal.Width") as "Sepal.Width" from iris group by species')

(console)
> result <- sqldf('select avg("Sepal.Length") as "Sepal.Length",avg("Sepal.Width") as "Sepal.Width" from iris group by species')
> result
  Sepal.Length Sepal.Width
1        5.006       3.428
2        5.936       2.770
3        6.588       2.974
```

- (sqldf) titanic.csv 파일을 가져와서 이용하여 pclass 별 생존율을 조사하시오.

```bash
tt <- read.csv("titanic.csv",header=TRUE,stringsAsFactors = FALSE,na.string="NA")
head(tt)

#pclass 별 생존율을 조사하시오.
result2 <- sqldf('select pclass,avg(survived) from tt group by pclass')

#pclass, 성별 생존육을 조사하시오.
result3 <- sqldf('select pclass,sex,avg(survived) from tt group by pclass,sex')

(console)
> #pclass 별 생존율을 조사하시오.
> result2 <- sqldf('select pclass,avg(survived) from tt group by pclass')
> result2
  pclass avg(survived)
1    1st     0.6191950
2    2nd     0.4296029
3    3rd     0.2552891


> #pclass, 성별 생존육을 조사하시오.
> result3 <- sqldf('select pclass,sex,avg(survived) from tt group by pclass,sex')
> result3
  pclass    sex avg(survived)
1    1st female     0.9652778
2    1st   male     0.3407821
3    2nd female     0.8867925
4    2nd   male     0.1461988
5    3rd female     0.4907407
6    3rd   male     0.1521298


```

>  :arrow_up_small: 참고 _ CSV 를 저장할 때 UTF-8 로 저장해야 R studio 에서 view에서 한글이 깨지지 않는다. 



## 텍스트 마이닝

- 문자로 된 데이터에서 가치 있는 정보를 얻어 내는 분석 기법이다.
- 가장 먼저 하는 작업은 문장을 구성하는 어절들이 어떤 품사로 되어 있는지 파악하는 '형태소 분석' 입니다.

> 형태소 분석 : 어절들의 품사를 파악한 후 명사, 동사 ,형요사 등 의미를 지닌 품사의 단어들을 추출해 ㅅㅁ각 단어가 얼마나 많이 등장했는지 확인한다.

- 텍스트 마이닝 준비하기
  1. 패키지를 준비한다.
     - 한극 자연어 분석 패키지인 KoNLP을 이용하면 한글 데이터로 형태소 분석을 할 수 있다. 

>  KoNLP 는 자바(JAVA) 가 설치되어 있어야 사용할 수 있다.                  

​		   2.KoNLP를 사용하려면 rJava, , memoise 패키지가 설치되어 있어야 합              			  니다. 두 패키지를 설치한 후 KoNLP를 설치합니다. 

```bash
install.packages("rJava")
install.packages("memoise")
install.packages("KoNLP")
```

​			3.설치가 완료되면 KoNLP와 전처리 작업에 사용할 dplyr을 로드한다.

```bash
library(KoNLP)
library(dplyr)
```

​			4. 사전 설정하기

   - KoNLP에서 지원하는 NIA 사전은 98만여 개의 단어로 구성되어 있다. 	           형태소 분석을 하는 데 이 사전을 이용하도록 설정한다.

     ```bash
     useNIADic()
     ```

        5. 데이터 준비하기

           - 먼저 깃허브(bit.ly/doit_rd)에서 hiphop.txt 파일을 다운로드해 프로젝트 폴더에 삽입한 다음, readLines()로 불러와 일부를 출력해 본다.  

             ```bash
             #데이터 불러온다
             txt <- readLines("hiphop.txt")
             head(txt)
             ```

​          6. 특구문자 제거하기

​           - 문장에 이모티콘이나 특수문자가 포함되어 있으면 오류가 발생할 수 있        			 습니다.  문자 처리 패키지인 stringr 의 str_replace_all() 을 이용해 문장			 에 들어 있는 특수문자를 빈칸으로 수정하겠습니다. 			

​			

```bash
install.packages("stringr")
library(stringr)

#특수문자 제거 
txt <- str_raplace_all(txt,"\\W", " ")
```

> \\W는 특수문자를 의미하는 '정규 표현식' 입니다. 



##### 가장 많이 사용된 단어 알아보기 

1. 명사 추출하기 

   - 먼저 가사에서 명사를 추출해 보겠습니다. KoNLP의 extractNoun()를 이용하면 문장에서 명사를 추출할 수 있습니다.

     ```bash
     #가사에서 명사 추출
     nouns <- extractNoun(txt)
     
     #추출한 명사 list를 문자열 백터로 변환, 단어별 반도표 생성
     wordcount <- table(unlist(nouns))
     
     #데이터 프레임으로 변환
     df_word <- as.data.frame(wordcount, stringsAsFactors = F)
     
     #변수명 수정 (colname을 사용해도 됨.) 
     df_word <- raname(df_word,
     				  word = Var1,
     				  freq = Freq)
     ```

     



    2. 자주 사용된 단어  빈도표 만들기 

  (여기부터!!!!)



















## 대한민국 시도별 인구 단계 구분도 만들기 

1. 패키지 준비하기 

   ```bash
   install.packages("stringi")
   
   install.packages("devtools")
   devtools::install_github("cardiomoon/kormaps2014")
   ```

   