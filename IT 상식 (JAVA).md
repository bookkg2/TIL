IT 상식 (JAVA)

- 융합 

- 객체 지향 VS 절차 지향

  - 절차 지향 프로그래미은  순차적인 처리가 중요시 된다.

    - 장점 : 컴퓨터의 처리구조가 유사해 실행속도가 빠름
    - 단점 : 유지보수가 어려움 , 실행순서가 정해져 있어 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움, 디버깅이 어려움

  - 소프트웨어 개발의 발달로 하드웨어가 소프트웨어의 발달을 따라오지 못해 객체지향 언어가 등장  + 프로그램의 크기가 커지면서 유지 관리해야 되는 경우가 많다.

  - 객체지향은 개발하려는 것을 기능별로 묶어 모듈화 함으로써 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고 하드웨어의 처리양을 획기적으로 줄여줌

  - 객체지향의 정의는 실제 세계를 모델링하여 소프트웨어를 개발 하는 것 

    - 데이터의 절차를 하나의 덩어리로 묶음

    - 객체 지향의 3대 특성

      - 1. 캡슐화 : 관련된 데이터와 알고리즘(코드)이 하나의 묶음으로, 관련된 코드와 데이터가 묶여있고 오류가 없어 사용이 편함. 데이터를 감추고 외부 세계와의 상호작용은 메소드를 통하는 방법  (즉 객채의 내부구조를 얻기 못하며 필드와 메소드만 이용)

           - 은닉성 : 데이터나 기능을 외부에서 접근 못하게 한다. (Public,Private,Protected)

             > 접근제어자 : Public은 어떤 클래스에서도 접근이 가능
             >
             > ​                       Protected는 동일 패키지내의 클래스 또는 상속						받은 외부 클래스 내에서만 접근 가능
             >
             > ​					  default : 해당 패키지 내에서만 접근 가능
             >
             > ​                      Private : 해당 클래스 내에서만 접근 가능

           - 추상화와 연관 내용물 까지는 알필요없이 클래스를 가져다 쓸수 있다. 

           > 메소드 : 메시지에 따라 실행시킬 프로시저

        2. 상속 : 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 기법

        3. 다형성 : 하나의 이름으로 많은 상황에 대처하는 기법. 개념적으로 동일한 작업을 수행하는 함수들에 똑같은 이름을 부여해서 코드가 간단해짐

           - 부모클래스에서 상속받아 함수를 만들면 그 함수를 자식클래스들은 여러개로 변경가능하다는 의미 !!
           - 예) 타이어하나의 객체를 만들어 여러 기업에서 가져와 변경하고 사용할 수 있다.

      - 장점 : 코드의 재활용성이 높음, 코딩이 절차지향보다 간편, 디버깅이 쉬움

      - 단점 : 처리속도가 절차 지향보다 느림, 설계에 많은 시간소요가 들어감

  - 객체 지향은 Stack에 쌓고 불러서 실행하니 시간이 오래 걸린다. 

    > 인터프리터 : 한줄씩 실행하고 실행한다. (step by step) (ex) Script -> 즉시로 확인 하기 좋은 거임 (단타에 좋음)
    >
    > 컴파일러 : 전체를 읽고 실행 (ex) java, c -> 긴 코드는 다시 실행 하면 속도가 빠름

    

- 둘의 대표 언어 

  - 절차지향언어 : C언어
  - 객체지향언어 :  JAVA, C++, C#, 닷넷, JAVASCRIPT

- 데이터 타입

  - 데이터 타입과 변수의 차이

    

    - 변수란 : 값을 저장할 수 있는 메모리 공간 (숫자값이 반복 되는 경우 처음부터 계산되는 것을 막기 위해)

    - 모든 변수에는 타입이 있으며 타입에 딸라 값의 종류와 범위가 달라진다. 

    - int ( 변수 타입)  변수이름

    - 타입은 크게 기본형과 참고형으로 나뉜다. 

      - 기본형은 논리형, 문자형 , 정수형 , 실수형으로 나뉨

        - 문자형 : 모든 데이터는 숫자로 저장

        - 정수형 : 자신의 저장할 수 있는 범위를 넘어서면 가장 적은 값부터 다시 반복 (오버플로우)

        - 실수형 : 부동소수점 방식으로 저장
          - float의 리커럴는 접미사 f, double은 d가 사용된다.

      - 참조형은 어떤 값이나 형식이 저장되어 있는 주소값을 나타낸다.

  - Value Type vs Reference Type 차이

    - 값형은 자신이 직접 데이터를 저장해서 보관하는 자료형 , 참조형은 데이터가 있는 위치만 자신이 가지고 있다가 필요할 때 그 데이터가 있는 곳으로 감
    - 값형 변수는 Stack 영역에 데이터가 저장
    - 참조형은 Heap 영역에 데이터를 저장
    - **Reference Type**에는 Copy도 **Swallow copy**와 **Deep copy**가 **존재**

  - Char 와 String type 나뉜 이유

    - String 객체는 final한 클래스로서 상속이 불가능
    - 내부적으로char 배열에 데이터를 저장하여 보관
    - 문자열 = 문자+문자

  - heap 영역과 Stack 영역

    - 스택은 아래 그림에서 처럼 차곡차곡 데이터가 메모리에 아래서부터 쌓이고 위에 부터 제거

    - 힙은 자유 기억공간이라고도 불리는데 , 적정한 곳에 데이터를 자유롭게 저장하고 제거하는 방식 (그곳의 주소를 기억하고 있는 참조형을 이용)

      > C++은 사용하던 자원을 해제하는 코드가 필요했지만, C#은 GC가 해준다.

  - 왜 Stack 이 있는지

- 데이터 비교 

  - .equals와 == 비교 차이 

    - equals는 메소드 , 대상의 내용 자체를 비교

    - == 는 비교 연산자, 주소값을 비교

    - > CBV : 대상에 주소값을 가지지 않는 것
      >
      > CBR :  주소값이 부여된 것

  - equals에서 두개의 객체가 같은거 비교 방법

    - String 은 참고형일 때 equals 여도 자체 오버라이드해서 값이 같으면 True 이지만 객체를 만들어서 비교하면 알 수 었으니 False가 나온다. 

      ```java
      String str1 = "hello";
      String str2 = "hello";
      System.out.println(str1.equals(str2));//true
      String str3 = new String("hello");
      String str4 = new String("hello");
      System.out.println(str3.equals(str4));//true
      
      
      ```

      ```java
      Person person1 = new Person("jeong-pro", 27);
      Person person2 = new Person("jeong-pro", 27);
      System.out.println(person1 == person2);//false
      System.out.println(person1.equals(person2));//false
      
      ```

      

  - String = 12345 와 New String 의 차이

    - 리터럴로 생성하는 경우 JVM 메모리에 있는 상수풀로 들어감(Intern에 의해)

      - 즉 동일한 문자열이면 같은 래퍼런스를 참조

    - new string 을 하면 다른 래퍼런스에 담김 , 메모리 힙 영역에 서로 달리 자리매김 함 (단 new String("").intern(); 하면 동시에 상수풀에 등록됨)

    - 결론은 String 객체로  = 연산으로 문자열을 삽입하거나 += 연산으로 문자열을 합치는 행위를 할때는 이전에 있던 객체(ABC)는 GC의 대상이되고 새로운 객체(ABCDEF)가 생성되어 집니다.

       즉, 문자열이 합쳐지는게 아니라 새로운 객체가 생성된다고 보시면 됩니다.

      - String 객체는 자체를 new 하고 값을 다시 변경하지만(append 불가),

       StringBuffer, StringBuilder 객체는 안에 있는 char 배열 데이터만 변경하는 차이 인것 입니다.

      

      

  - equals가 같은 메모리를 참조하고 있다.

  - hashcode에 대하여 설명

    - 객체를 식별할 하나의 정수값을 말한다. 
    - 우선 hashCode() 메소드를 실행해서 리턴된 해시코드 값이 같은지를 본다. 해시 코드값이 다르면 다른 객체로 판단하고, 해시 코드값이 같으면 equals()메소드로 다시 비교한다. 이두개가 모두 맞아야 동등 객체로 판단한다

  - .equals가 어떻게 해서 hashcode가 같은지를  판단

  - hashcode 이용해서 같은 객체 인지를 비교하는 방법

    - ```java
      @Override
      public int hashCode() {
        return Objects.hash(field1, field2, filed3);
      }
      ```

    - 

  - class 내 Name 애트리 뷰트 값이 같으면 같다를 어떻게 나타내는지 

- 메모리 관련

  - Java 메모리 구조
  
  - String = "12345" 와 String = new String("12345") 중 어느 방법이 더 좋은가 
  
  - String pool
  
    - String pool 은 java 6 버전까지 Perm 영역이었다.
  
      하지만 Perm 영역은 고정된 사이즈이며 Runtime 에 사이즈가 확장되지 않는다
  
      그래서 intern 되는 String 값이 커지면 OutOfMemoryException을 발생시킬 수 있었고 그에따라 java 7 버전에서 heap 영역으로 String pool 의 위치를 변경하였다.
  
      > 펌( PERM : Permanent Generation) 영역은 객체의 생명주기가 영구적일 것으로 생각하는 객체들을 관리한다. 이 영역은 GC대상에서 제외된다. 
      >
      > 주로 자바의 Class 객체들이나 문자열에 속한 String 객체들이 위치한다.
      >
      > 
  
      
  
      - String pool 참조가 아닌 리터럴을 이용해서 String을 넣을 경우 pool에 담긴다.
  
  - 맴버 변수와 지역 변수 둥 Stack 영역에 저장되는 변수는 ?
  
    - 지역변수
  
  - 맴버 변수와 지역변수는 언제 메모리에서 해제 ?
  
     
  
    - 지역변수는 함수의 호출이 완료되면 소멸
    - 맴버 변수는 객체를 더이상 참조하는 참조 변수가 없을 때 소멸
  
  - heap 영역에 저장이 되는 변수는 언제 해제 ?
  
    - JVM이 종료되면
  
  - 참조 타입의 주소는 어디에 저장?
  
    - stack
  
  - 주소값은 왜 stack에 저장이 되는가 ?

